This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
composer.json
config/digidocs.php
config/pricing.php
phpunit.xml
README.md
src/Agent/DocumentationAgent.php
src/Agent/ChangeAnalysisAgent.php
src/Commands/AutoDocsCommand.php
src/Commands/WatchCommand.php
src/DigidocsServiceProvider.php
src/Services/CodeVisitor.php
src/Services/CostTracker.php
src/Services/DocumentationAnalyzer.php
src/Services/GitWatcherService.php
src/Services/MemoryService.php
src/Schema/DocumentationSchema.php
src/Schema/SimpleDocumentationSchema.php
src/Tools/AstCompareTool.php
src/Tools/CodeAnalyzerTool.php
src/Tools/CodeDiffTool.php
src/Tools/FileHashTool.php
src/Tools/GitAnalyzerTool.php
src/Tools/SemanticAnalysisTool.php
tests/DigidocsTestCase.php
tests/Feature/AutoDocsCommandTest.php
tests/Feature/ChangeAnalysisAgentTest.php
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
/vendor/
composer.lock
.phpunit.cache/
.env
.env.testing
node_modules/
npm-debug.log
yarn-error.log
/.idea
/.vscode
</file>

<file path="config/pricing.php">
<?php

return [
    /*
    |--------------------------------------------------------------------------
    | AI Model Pricing Configuration
    |--------------------------------------------------------------------------
    |
    | Ceny modelů AI v USD za milion tokenů (MTok).
    | Aktualizováno: 2025-01-14
    |
    | Podporované providery v NeuronAI:
    | - OpenAI
    | - Anthropic
    | - Gemini (Google)
    | - Ollama (lokální modely - zdarma)
    | - Deepseek
    | - Mistral
    | - AzureOpenAI
    |
    */

    'providers' => [
        
        /*
        |--------------------------------------------------------------------------
        | OpenAI Models
        |--------------------------------------------------------------------------
        | Zdroj: https://openai.com/api/pricing/
        | Aktualizováno: 2025-01-14
        */
        'openai' => [
            // GPT-4.1 series (nejnovější)
            'gpt-4.1' => [
                'input' => 2.00,    // $2.00 / 1M tokens
                'output' => 8.00,   // $8.00 / 1M tokens
            ],
            'gpt-4.1-mini' => [
                'input' => 0.40,    // $0.40 / 1M tokens
                'output' => 1.60,   // $1.60 / 1M tokens
            ],
            'gpt-4.1-nano' => [
                'input' => 0.10,    // $0.10 / 1M tokens
                'output' => 0.40,   // $0.40 / 1M tokens
            ],
            'gpt-4.1-nano-2025-04-14' => [
                'input' => 0.10,    // $0.10 / 1M tokens
                'output' => 0.40,   // $0.40 / 1M tokens
            ],

            // GPT-4o series
            'gpt-4o' => [
                'input' => 5.00,    // $5.00 / 1M tokens
                'output' => 20.00,  // $20.00 / 1M tokens
            ],
            'gpt-4o-mini' => [
                'input' => 0.60,    // $0.60 / 1M tokens
                'output' => 2.40,   // $2.40 / 1M tokens
            ],

            // Legacy models
            'gpt-4' => [
                'input' => 30.00,   // $30.00 / 1M tokens
                'output' => 60.00,  // $60.00 / 1M tokens
            ],
            'gpt-4-turbo' => [
                'input' => 10.00,   // $10.00 / 1M tokens
                'output' => 30.00,  // $30.00 / 1M tokens
            ],
            'gpt-3.5-turbo' => [
                'input' => 1.50,    // $1.50 / 1M tokens
                'output' => 2.00,   // $2.00 / 1M tokens
            ],

            // Reasoning models
            'o3' => [
                'input' => 10.00,   // $10.00 / 1M tokens
                'output' => 40.00,  // $40.00 / 1M tokens
            ],
            'o4-mini' => [
                'input' => 1.10,    // $1.10 / 1M tokens
                'output' => 4.40,   // $4.40 / 1M tokens
            ],
        ],

        /*
        |--------------------------------------------------------------------------
        | Anthropic Models
        |--------------------------------------------------------------------------
        | Zdroj: https://docs.anthropic.com/en/docs/about-claude/models/overview
        | Aktualizováno: 2025-01-14
        */
        'anthropic' => [
            // Claude 4 series (nejnovější)
            'claude-opus-4' => [
                'input' => 15.00,   // $15.00 / MTok
                'output' => 75.00,  // $75.00 / MTok
            ],
            'claude-opus-4-20250514' => [
                'input' => 15.00,   // $15.00 / MTok
                'output' => 75.00,  // $75.00 / MTok
            ],
            'claude-sonnet-4' => [
                'input' => 3.00,    // $3.00 / MTok
                'output' => 15.00,  // $15.00 / MTok
            ],
            'claude-sonnet-4-20250514' => [
                'input' => 3.00,    // $3.00 / MTok
                'output' => 15.00,  // $15.00 / MTok
            ],

            // Claude 3.7 series
            'claude-3-7-sonnet-20250219' => [
                'input' => 3.00,    // $3.00 / MTok
                'output' => 15.00,  // $15.00 / MTok
            ],

            // Claude 3.5 series
            'claude-3-5-sonnet-20241022' => [
                'input' => 3.00,    // $3.00 / MTok
                'output' => 15.00,  // $15.00 / MTok
            ],
            'claude-3-5-sonnet-20240620' => [
                'input' => 3.00,    // $3.00 / MTok
                'output' => 15.00,  // $15.00 / MTok
            ],
            'claude-3-5-haiku-20241022' => [
                'input' => 0.80,    // $0.80 / MTok
                'output' => 4.00,   // $4.00 / MTok
            ],

            // Claude 3 series (legacy)
            'claude-3-opus-20240229' => [
                'input' => 15.00,   // $15.00 / MTok
                'output' => 75.00,  // $75.00 / MTok
            ],
            'claude-3-sonnet-20240229' => [
                'input' => 3.00,    // $3.00 / MTok
                'output' => 15.00,  // $15.00 / MTok
            ],
            'claude-3-haiku-20240307' => [
                'input' => 0.25,    // $0.25 / MTok
                'output' => 1.25,   // $1.25 / MTok
            ],
        ],

        /*
        |--------------------------------------------------------------------------
        | Google Gemini Models
        |--------------------------------------------------------------------------
        | Zdroj: https://ai.google.dev/gemini-api/docs/pricing
        | Aktualizováno: 2025-01-14
        */
        'gemini' => [
            'gemini-1.5-pro' => [
                'input' => 1.25,    // $1.25 / 1M tokens
                'output' => 5.00,   // $5.00 / 1M tokens
            ],
            'gemini-1.5-flash' => [
                'input' => 0.075,   // $0.075 / 1M tokens
                'output' => 0.30,   // $0.30 / 1M tokens
            ],
            'gemini-2.0-flash' => [
                'input' => 0.075,   // $0.075 / 1M tokens
                'output' => 0.30,   // $0.30 / 1M tokens
            ],
        ],

        /*
        |--------------------------------------------------------------------------
        | Deepseek Models
        |--------------------------------------------------------------------------
        | Zdroj: https://platform.deepseek.com/api-docs/pricing
        | Aktualizováno: 2025-01-14
        */
        'deepseek' => [
            'deepseek-chat' => [
                'input' => 0.14,    // $0.14 / 1M tokens
                'output' => 0.28,   // $0.28 / 1M tokens
            ],
            'deepseek-coder' => [
                'input' => 0.14,    // $0.14 / 1M tokens
                'output' => 0.28,   // $0.28 / 1M tokens
            ],
        ],

        /*
        |--------------------------------------------------------------------------
        | Mistral Models
        |--------------------------------------------------------------------------
        | Zdroj: https://mistral.ai/technology/#pricing
        | Aktualizováno: 2025-01-14
        */
        'mistral' => [
            'mistral-large' => [
                'input' => 2.00,    // $2.00 / 1M tokens
                'output' => 6.00,   // $6.00 / 1M tokens
            ],
            'mistral-medium' => [
                'input' => 2.70,    // $2.70 / 1M tokens
                'output' => 8.10,   // $8.10 / 1M tokens
            ],
            'mistral-small' => [
                'input' => 0.20,    // $0.20 / 1M tokens
                'output' => 0.60,   // $0.60 / 1M tokens
            ],
        ],

        /*
        |--------------------------------------------------------------------------
        | Ollama Models (lokální)
        |--------------------------------------------------------------------------
        | Ollama modely běží lokálně, takže jsou zdarma
        */
        'ollama' => [
            'default' => [
                'input' => 0.00,    // Zdarma
                'output' => 0.00,   // Zdarma
            ],
        ],

        /*
        |--------------------------------------------------------------------------
        | Azure OpenAI Models
        |--------------------------------------------------------------------------
        | Ceny jsou stejné jako OpenAI, ale mohou se lišit podle regionu
        */
        'azure' => [
            'gpt-4' => [
                'input' => 30.00,   // $30.00 / 1M tokens
                'output' => 60.00,  // $60.00 / 1M tokens
            ],
            'gpt-4o' => [
                'input' => 5.00,    // $5.00 / 1M tokens
                'output' => 20.00,  // $20.00 / 1M tokens
            ],
            'gpt-3.5-turbo' => [
                'input' => 1.50,    // $1.50 / 1M tokens
                'output' => 2.00,   // $2.00 / 1M tokens
            ],
        ],
    ],

    /*
    |--------------------------------------------------------------------------
    | Default Fallback Pricing
    |--------------------------------------------------------------------------
    | Použije se pro neznámé modely
    */
    'default' => [
        'input' => 1.00,    // $1.00 / 1M tokens
        'output' => 2.00,   // $2.00 / 1M tokens
    ],

    /*
    |--------------------------------------------------------------------------
    | Pricing Metadata
    |--------------------------------------------------------------------------
    */
    'metadata' => [
        'last_updated' => '2025-01-14',
        'currency' => 'USD',
        'unit' => 'per 1M tokens',
        'sources' => [
            'openai' => 'https://openai.com/api/pricing/',
            'anthropic' => 'https://docs.anthropic.com/en/docs/about-claude/models/overview',
            'gemini' => 'https://ai.google.dev/gemini-api/docs/pricing',
            'deepseek' => 'https://platform.deepseek.com/api-docs/pricing',
            'mistral' => 'https://mistral.ai/technology/#pricing',
        ],
    ],
];
</file>

<file path="phpunit.xml">
<?xml version="1.0" encoding="UTF-8"?>
<phpunit
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="https://schema.phpunit.de/10.0/phpunit.xsd"
    bootstrap="vendor/autoload.php"
    colors="true"
    processIsolation="false"
    stopOnFailure="false"
    executionOrder="random"
    failOnWarning="true"
    failOnRisky="true"
    failOnEmptyTestSuite="true"
    beStrictAboutOutputDuringTests="true"
    cacheDirectory=".phpunit.cache"
    backupStaticProperties="false"
>
    <testsuites>
        <testsuite name="Digidocs Test Suite">
            <directory>tests</directory>
        </testsuite>
    </testsuites>
    <source>
        <include>
            <directory suffix=".php">./src</directory>
        </include>
    </source>
</phpunit>
</file>

<file path="src/Services/CodeVisitor.php">
<?php

namespace Digihood\Digidocs\Services;

use PhpParser\Node;
use PhpParser\NodeVisitorAbstract;
use PhpParser\Node\Stmt\Class_;
use PhpParser\Node\Stmt\ClassMethod;
use PhpParser\Node\Stmt\Property;
use PhpParser\Node\Stmt\Namespace_;
use PhpParser\Node\Stmt\Use_;

class CodeVisitor extends NodeVisitorAbstract
{
    private ?string $namespace = null;
    private array $classes = [];
    private array $methods = [];
    private array $properties = [];
    private array $imports = [];
    private array $existingDocs = [];

    public function enterNode(Node $node)
    {
        // Namespace
        if ($node instanceof Namespace_) {
            $this->namespace = $node->name ? $node->name->toString() : null;
        }

        // Imports (use statements)
        if ($node instanceof Use_) {
            foreach ($node->uses as $use) {
                $this->imports[] = [
                    'name' => $use->name->toString(),
                    'alias' => $use->alias ? $use->alias->toString() : null
                ];
            }
        }

        // Classes
        if ($node instanceof Class_) {
            $className = $node->name->toString();
            
            $classInfo = [
                'name' => $className,
                'extends' => $node->extends ? $node->extends->toString() : null,
                'implements' => array_map(fn($interface) => $interface->toString(), $node->implements),
                'is_abstract' => $node->isAbstract(),
                'is_final' => $node->isFinal(),
                'docblock' => $this->extractDocComment($node),
                'line' => $node->getStartLine(),
            ];

            $this->classes[] = $classInfo;
        }

        // Methods
        if ($node instanceof ClassMethod) {
            $methodInfo = [
                'name' => $node->name->toString(),
                'is_public' => $node->isPublic(),
                'is_protected' => $node->isProtected(),
                'is_private' => $node->isPrivate(),
                'is_static' => $node->isStatic(),
                'is_abstract' => $node->isAbstract(),
                'is_final' => $node->isFinal(),
                'parameters' => $this->extractParameters($node),
                'return_type' => $node->returnType ? $node->returnType->toString() : null,
                'docblock' => $this->extractDocComment($node),
                'line' => $node->getStartLine(),
            ];

            $this->methods[] = $methodInfo;
        }

        // Properties
        if ($node instanceof Property) {
            foreach ($node->props as $prop) {
                $propertyInfo = [
                    'name' => $prop->name->toString(),
                    'is_public' => $node->isPublic(),
                    'is_protected' => $node->isProtected(),
                    'is_private' => $node->isPrivate(),
                    'is_static' => $node->isStatic(),
                    'type' => $node->type ? $node->type->toString() : null,
                    'default' => $prop->default ? $this->nodeToString($prop->default) : null,
                    'docblock' => $this->extractDocComment($node),
                    'line' => $node->getStartLine(),
                ];

                $this->properties[] = $propertyInfo;
            }
        }

        return null;
    }

    public function getNamespace(): ?string
    {
        return $this->namespace;
    }

    public function getClasses(): array
    {
        return $this->classes;
    }

    public function getMethods(): array
    {
        return $this->methods;
    }

    public function getProperties(): array
    {
        return $this->properties;
    }

    public function getImports(): array
    {
        return $this->imports;
    }

    public function getExistingDocs(): array
    {
        return $this->existingDocs;
    }

    /**
     * Extrahuje parametry metody
     */
    private function extractParameters(ClassMethod $method): array
    {
        $parameters = [];
        
        foreach ($method->params as $param) {
            $paramInfo = [
                'name' => $param->var->name,
                'type' => $param->type ? $param->type->toString() : null,
                'is_nullable' => $param->type && $param->type instanceof Node\NullableType,
                'has_default' => $param->default !== null,
                'default' => $param->default ? $this->nodeToString($param->default) : null,
                'is_variadic' => $param->variadic,
                'is_reference' => $param->byRef,
            ];

            $parameters[] = $paramInfo;
        }

        return $parameters;
    }

    /**
     * Extrahuje doc comment z nodu
     */
    private function extractDocComment(Node $node): ?array
    {
        $docComment = $node->getDocComment();
        
        if (!$docComment) {
            return null;
        }

        $text = $docComment->getText();
        
        return [
            'raw' => $text,
            'summary' => $this->extractSummary($text),
            'description' => $this->extractDescription($text),
            'tags' => $this->extractTags($text),
        ];
    }

    /**
     * Extrahuje summary z docblocku
     */
    private function extractSummary(string $docblock): ?string
    {
        $lines = explode("\n", $docblock);
        foreach ($lines as $line) {
            $line = trim($line, " \t\n\r\0\x0B/*");
            if (!empty($line) && !str_starts_with($line, '@')) {
                return $line;
            }
        }
        return null;
    }

    /**
     * Extrahuje description z docblocku
     */
    private function extractDescription(string $docblock): ?string
    {
        $lines = explode("\n", $docblock);
        $description = [];
        $inDescription = false;

        foreach ($lines as $line) {
            $line = trim($line, " \t\n\r\0\x0B/*");
            
            if (empty($line)) {
                if ($inDescription) {
                    $description[] = '';
                }
                continue;
            }

            if (str_starts_with($line, '@')) {
                break;
            }

            if ($inDescription || !empty($description)) {
                $description[] = $line;
                $inDescription = true;
            } else {
                // První neprázdný řádek je summary, druhý začíná description
                $inDescription = true;
            }
        }

        return !empty($description) ? implode("\n", $description) : null;
    }

    /**
     * Extrahuje tagy z docblocku
     */
    private function extractTags(string $docblock): array
    {
        $lines = explode("\n", $docblock);
        $tags = [];

        foreach ($lines as $line) {
            $line = trim($line, " \t\n\r\0\x0B/*");
            
            if (str_starts_with($line, '@')) {
                if (preg_match('/^@(\w+)(?:\s+(.*))?$/', $line, $matches)) {
                    $tagName = $matches[1];
                    $tagValue = $matches[2] ?? '';
                    
                    if (!isset($tags[$tagName])) {
                        $tags[$tagName] = [];
                    }
                    
                    $tags[$tagName][] = $tagValue;
                }
            }
        }

        return $tags;
    }

    /**
     * Převede AST node na string reprezentaci
     */
    private function nodeToString(Node $node): string
    {
        // Jednoduchá implementace pro základní typy
        if ($node instanceof Node\Scalar\String_) {
            return "'{$node->value}'";
        }
        
        if ($node instanceof Node\Scalar\LNumber) {
            return (string) $node->value;
        }
        
        if ($node instanceof Node\Scalar\DNumber) {
            return (string) $node->value;
        }
        
        if ($node instanceof Node\Expr\ConstFetch) {
            return $node->name->toString();
        }

        if ($node instanceof Node\Expr\Array_) {
            return 'array(...)';
        }

        return 'mixed';
    }
}
</file>

<file path="src/Services/CostTracker.php">
<?php

namespace Digihood\Digidocs\Services;

use SplObserver;
use SplSubject;
use NeuronAI\AgentInterface;
use NeuronAI\Observability\Events\MessageSaved;
use Digihood\Digidocs\Services\MemoryService;

class CostTracker implements SplObserver
{
    private ?string $currentFilePath = null;

    public function __construct(
        private MemoryService $memory
    ) {}

    /**
     * Nastaví aktuální soubor pro tracking
     */
    public function setCurrentFile(?string $filePath): void
    {
        $this->currentFilePath = $filePath;
    }

    /**
     * Observer metoda pro sledování NeuronAI událostí
     */
    public function update(SplSubject $subject, ?string $event = null, mixed $data = null): void
    {
        if ($event === 'message-saved' && $data instanceof MessageSaved) {
            $this->handleMessageSaved($subject, $data);
        }
    }

    /**
     * Zpracuje uloženou zprávu s Usage informacemi
     */
    private function handleMessageSaved(AgentInterface $agent, MessageSaved $data): void
    {
        $usage = $data->message->getUsage();

        if (!$usage) {
            return;
        }

        $model = $this->getModelFromAgent($agent);
        $cost = $this->calculateCost($model, $usage->inputTokens, $usage->outputTokens);

        // Zaznamenej do databáze
        $this->memory->recordTokenUsage(
            $model,
            $usage->inputTokens,
            $usage->outputTokens,
            $cost,
            $this->currentFilePath
        );
    }

    /**
     * Získá model z agenta
     */
    private function getModelFromAgent(AgentInterface $agent): string
    {
        try {
            $provider = $agent->resolveProvider();

            // Pro OpenAI - zkus různé způsoby získání modelu
            if (method_exists($provider, 'getModel')) {
                return $provider->getModel();
            }

            // Zkus reflection pro protected/private properties
            $reflection = new \ReflectionClass($provider);

            // Zkus property 'model'
            if ($reflection->hasProperty('model')) {
                $modelProperty = $reflection->getProperty('model');
                $modelProperty->setAccessible(true);
                return $modelProperty->getValue($provider);
            }

            // Fallback na název třídy
            $className = get_class($provider);
            $baseName = basename(str_replace('\\', '/', $className));
            return strtolower($baseName);

        } catch (\Exception $e) {
            return 'unknown';
        }
    }

    /**
     * Vypočítá náklady na základě modelu a tokenů
     */
    public function calculateCost(string $model, int $inputTokens, int $outputTokens): float
    {
        $rates = $this->getModelRates($model);

        $inputCost = ($inputTokens / 1000000) * $rates['input'];
        $outputCost = ($outputTokens / 1000000) * $rates['output'];

        return $inputCost + $outputCost;
    }

    /**
     * Získá aktuální ceny pro model
     */
    public function getModelRates(string $model): array
    {
        return $this->getModelRatesFromConfig($model);
    }

    /**
     * Získá ceny modelu z config souboru
     */
    private function getModelRatesFromConfig(string $model): array
    {
        $pricingConfig = config('digidocs.pricing', []);

        // Pokud není config načten, zkus načíst přímo
        if (empty($pricingConfig)) {
            $pricingConfig = include __DIR__ . '/../../config/pricing.php';
        }

        // Zkus najít model přímo
        if ($this->findModelInProviders($model, $pricingConfig['providers'] ?? [])) {
            return $this->findModelInProviders($model, $pricingConfig['providers']);
        }

        // Fallback na default ceny (už v MTok)
        return $pricingConfig['default'] ?? ['input' => 1.00, 'output' => 2.00];
    }

    /**
     * Najde model v providers konfiguraci
     */
    private function findModelInProviders(string $model, array $providers): ?array
    {
        foreach ($providers as $providerName => $models) {
            if (isset($models[$model])) {
                // Ceny jsou už v MTok, takže je vrátíme přímo
                return [
                    'input' => $models[$model]['input'],
                    'output' => $models[$model]['output'],
                ];
            }
        }

        // Zkus najít podle prefixu modelu
        $provider = $this->detectProviderFromModel($model);
        if ($provider && isset($providers[$provider])) {
            // Zkus najít podobný model
            $similarModel = $this->findSimilarModel($model, $providers[$provider]);
            if ($similarModel) {
                return [
                    'input' => $similarModel['input'],
                    'output' => $similarModel['output'],
                ];
            }
        }

        return null;
    }

    /**
     * Detekuje providera z názvu modelu
     */
    private function detectProviderFromModel(string $model): ?string
    {
        if (str_starts_with($model, 'gpt-') || str_starts_with($model, 'o3') || str_starts_with($model, 'o4-')) {
            return 'openai';
        }

        if (str_starts_with($model, 'claude-')) {
            return 'anthropic';
        }

        if (str_starts_with($model, 'gemini-')) {
            return 'gemini';
        }

        if (str_starts_with($model, 'deepseek-')) {
            return 'deepseek';
        }

        if (str_starts_with($model, 'mistral-')) {
            return 'mistral';
        }

        return null;
    }

    /**
     * Najde podobný model v rámci providera
     */
    private function findSimilarModel(string $model, array $providerModels): ?array
    {
        // Pro OpenAI modely
        if (str_starts_with($model, 'gpt-4.1-nano')) {
            return $providerModels['gpt-4.1-nano'] ?? null;
        }

        if (str_starts_with($model, 'gpt-4.1-mini')) {
            return $providerModels['gpt-4.1-mini'] ?? null;
        }

        if (str_starts_with($model, 'gpt-4.1')) {
            return $providerModels['gpt-4.1'] ?? null;
        }

        if (str_starts_with($model, 'gpt-4o-mini')) {
            return $providerModels['gpt-4o-mini'] ?? null;
        }

        if (str_starts_with($model, 'gpt-4o')) {
            return $providerModels['gpt-4o'] ?? null;
        }

        if (str_starts_with($model, 'gpt-4')) {
            return $providerModels['gpt-4'] ?? null;
        }

        // Pro Anthropic modely
        if (str_contains($model, 'claude-4')) {
            if (str_contains($model, 'opus')) {
                return $providerModels['claude-opus-4'] ?? null;
            }
            if (str_contains($model, 'sonnet')) {
                return $providerModels['claude-sonnet-4'] ?? null;
            }
        }

        return null;
    }

    /**
     * Získá informace o zdroji cen pro model
     */
    public function getPricingSource(string $model): string
    {
        // Všechny ceny jsou z config souboru
        return 'config';
    }

    /**
     * Odhadne náklady pro text (bez skutečného volání API)
     */
    public function estimateCost(string $model, string $inputText, int $estimatedOutputTokens = 500): array
    {
        // Jednoduchý odhad tokenů (přibližně 4 znaky = 1 token)
        $estimatedInputTokens = (int) ceil(strlen($inputText) / 4);

        $cost = $this->calculateCost($model, $estimatedInputTokens, $estimatedOutputTokens);
        $rates = $this->getModelRates($model);

        return [
            'estimated_input_tokens' => $estimatedInputTokens,
            'estimated_output_tokens' => $estimatedOutputTokens,
            'estimated_total_tokens' => $estimatedInputTokens + $estimatedOutputTokens,
            'estimated_cost' => $cost,
            'model' => $model,
            'rates_per_mtok' => $rates,
            'rates_display' => [
                'input' => '$' . number_format($rates['input'], 2) . ' / 1M tokens',
                'output' => '$' . number_format($rates['output'], 2) . ' / 1M tokens',
            ]
        ];
    }
}
</file>

<file path="src/Services/DocumentationAnalyzer.php">
<?php

namespace Digihood\Digidocs\Services;

use PhpParser\Error;
use PhpParser\Node;
use PhpParser\NodeFinder;
use PhpParser\ParserFactory;

class DocumentationAnalyzer
{
    private $parser;
    private $nodeFinder;

    public function __construct()
    {
        $this->parser = (new ParserFactory)->createForNewestSupportedVersion();
        $this->nodeFinder = new NodeFinder;
    }

    /**
     * Analyzuj existující dokumentaci pro soubor
     */
    public function analyzeExistingDocumentation(string $filePath): ?array
    {
        $docPath = $this->getDocumentationPath($filePath);

        if (!file_exists($docPath)) {
            return null;
        }

        $content = file_get_contents($docPath);
        if (empty($content)) {
            return null;
        }

        return [
            'path' => $docPath,
            'content' => $content,
            'size' => strlen($content),
            'sections' => $this->parseDocumentationSections($content),
            'last_modified' => filemtime($docPath),
            'documented_elements' => $this->extractDocumentedElements($content)
        ];
    }

    /**
     * Vypočítej skóre relevance dokumentace (0-100)
     */
    public function calculateDocumentationRelevance(
        array $codeChanges,
        ?array $existingDoc
    ): int {
        if (!$existingDoc) {
            return 100; // Žádná dokumentace = vždy generuj
        }

        $relevanceScore = 0;
        $maxScore = 100;

        // Kontrola změn ve veřejných API
        if ($this->hasPublicApiChanges($codeChanges)) {
            $relevanceScore += 40;
        }

        // Kontrola změn v dokumentovaných částech
        if ($this->affectsDocumentedParts($codeChanges, $existingDoc)) {
            $relevanceScore += 30;
        }

        // Kontrola strukturálních změn
        if ($this->hasStructuralChanges($codeChanges)) {
            $relevanceScore += 20;
        }

        // Kontrola změn v komentářích/docblocks
        if ($this->hasDocumentationChanges($codeChanges)) {
            $relevanceScore += 10;
        }

        return min($relevanceScore, $maxScore);
    }

    /**
     * Parsuj strukturu kódu z obsahu souboru
     */
    public function parseCodeStructure(string $content): array
    {
        try {
            $ast = $this->parser->parse($content);
            if (!$ast) {
                return [];
            }

            $structure = [
                'classes' => [],
                'functions' => [],
                'interfaces' => [],
                'traits' => []
            ];

            // Najdi třídy
            $classes = $this->nodeFinder->findInstanceOf($ast, Node\Stmt\Class_::class);
            foreach ($classes as $class) {
                $structure['classes'][] = $this->extractClassInfo($class);
            }

            // Najdi funkce
            $functions = $this->nodeFinder->findInstanceOf($ast, Node\Stmt\Function_::class);
            foreach ($functions as $function) {
                $structure['functions'][] = $this->extractFunctionInfo($function);
            }

            // Najdi interface
            $interfaces = $this->nodeFinder->findInstanceOf($ast, Node\Stmt\Interface_::class);
            foreach ($interfaces as $interface) {
                $structure['interfaces'][] = $this->extractInterfaceInfo($interface);
            }

            // Najdi traits
            $traits = $this->nodeFinder->findInstanceOf($ast, Node\Stmt\Trait_::class);
            foreach ($traits as $trait) {
                $structure['traits'][] = $this->extractTraitInfo($trait);
            }

            return $structure;

        } catch (Error $e) {
            \Log::warning("Failed to parse PHP code: " . $e->getMessage());
            return [];
        }
    }

    /**
     * Získej cestu k dokumentačnímu souboru
     */
    private function getDocumentationPath(string $filePath): string
    {
        $docsPath = config('digidocs.paths.docs');
        $relativePath = str_replace(['app/', '.php'], ['', '.md'], $filePath);
        return $docsPath . '/' . $relativePath;
    }

    /**
     * Parsuj sekce v dokumentaci
     */
    private function parseDocumentationSections(string $content): array
    {
        $sections = [];
        $lines = explode("\n", $content);
        $currentSection = null;

        foreach ($lines as $line) {
            if (preg_match('/^#+\s+(.+)$/', $line, $matches)) {
                $currentSection = trim($matches[1]);
                $sections[$currentSection] = [];
            } elseif ($currentSection && !empty(trim($line))) {
                $sections[$currentSection][] = $line;
            }
        }

        return $sections;
    }

    /**
     * Extrahuj dokumentované elementy z obsahu dokumentace
     */
    private function extractDocumentedElements(string $content): array
    {
        $elements = [];

        // Najdi zmínky o třídách, metodách, vlastnostech
        if (preg_match_all('/(?:class|třída)\s+`?([A-Za-z_][A-Za-z0-9_]*)`?/i', $content, $matches)) {
            foreach ($matches[1] as $className) {
                $elements[] = ['type' => 'class', 'name' => $className];
            }
        }

        if (preg_match_all('/(?:method|metoda)\s+`?([A-Za-z_][A-Za-z0-9_]*)`?/i', $content, $matches)) {
            foreach ($matches[1] as $methodName) {
                $elements[] = ['type' => 'method', 'name' => $methodName];
            }
        }

        if (preg_match_all('/`([A-Za-z_][A-Za-z0-9_]*)\([^)]*\)`/', $content, $matches)) {
            foreach ($matches[1] as $functionName) {
                $elements[] = ['type' => 'function', 'name' => $functionName];
            }
        }

        return $elements;
    }

    /**
     * Zkontroluj zda změny ovlivňují veřejné API
     */
    private function hasPublicApiChanges(array $codeChanges): bool
    {
        if (!isset($codeChanges['old_structure']) || !isset($codeChanges['new_structure'])) {
            return false;
        }

        $oldStructure = $codeChanges['old_structure'];
        $newStructure = $codeChanges['new_structure'];

        // Porovnej veřejné metody tříd
        foreach ($newStructure['classes'] as $newClass) {
            $oldClass = $this->findClassByName($oldStructure['classes'], $newClass['name']);

            if (!$oldClass) {
                return true; // Nová třída
            }

            if ($this->hasPublicMethodChanges($oldClass['methods'], $newClass['methods'])) {
                return true;
            }
        }

        return false;
    }

    /**
     * Zkontroluj zda změny ovlivňují dokumentované části
     */
    private function affectsDocumentedParts(array $codeChanges, array $existingDoc): bool
    {
        if (!isset($existingDoc['documented_elements'])) {
            return false;
        }

        $documentedElements = $existingDoc['documented_elements'];
        $newStructure = $codeChanges['new_structure'] ?? [];

        foreach ($documentedElements as $element) {
            if (!$this->elementExistsInStructure($element, $newStructure)) {
                return true; // Dokumentovaný element byl odstraněn
            }
        }

        return false;
    }

    /**
     * Zkontroluj strukturální změny
     */
    private function hasStructuralChanges(array $codeChanges): bool
    {
        if (!isset($codeChanges['old_structure']) || !isset($codeChanges['new_structure'])) {
            return false;
        }

        $oldStructure = $codeChanges['old_structure'];
        $newStructure = $codeChanges['new_structure'];

        // Porovnej počty elementů
        return (
            count($oldStructure['classes']) !== count($newStructure['classes']) ||
            count($oldStructure['functions']) !== count($newStructure['functions']) ||
            count($oldStructure['interfaces']) !== count($newStructure['interfaces']) ||
            count($oldStructure['traits']) !== count($newStructure['traits'])
        );
    }

    /**
     * Zkontroluj změny v dokumentaci/komentářích
     */
    private function hasDocumentationChanges(array $codeChanges): bool
    {
        // Jednoduchá kontrola - pokud se změnil obsah, možná se změnily komentáře
        return isset($codeChanges['content_changed']) && $codeChanges['content_changed'];
    }

    /**
     * Extrahuj informace o třídě
     */
    private function extractClassInfo(Node\Stmt\Class_ $class): array
    {
        $methods = [];
        $properties = [];

        foreach ($class->stmts as $stmt) {
            if ($stmt instanceof Node\Stmt\ClassMethod) {
                $methods[] = [
                    'name' => $stmt->name->toString(),
                    'visibility' => $this->getVisibility($stmt),
                    'parameters' => $this->extractParameters($stmt->params),
                    'return_type' => $stmt->returnType ? $stmt->returnType->toString() : null
                ];
            } elseif ($stmt instanceof Node\Stmt\Property) {
                foreach ($stmt->props as $prop) {
                    $properties[] = [
                        'name' => $prop->name->toString(),
                        'visibility' => $this->getVisibility($stmt)
                    ];
                }
            }
        }

        return [
            'name' => $class->name->toString(),
            'methods' => $methods,
            'properties' => $properties,
            'extends' => $class->extends ? $class->extends->toString() : null,
            'implements' => array_map(fn($i) => $i->toString(), $class->implements)
        ];
    }

    /**
     * Extrahuj informace o funkci
     */
    private function extractFunctionInfo(Node\Stmt\Function_ $function): array
    {
        return [
            'name' => $function->name->toString(),
            'parameters' => $this->extractParameters($function->params),
            'return_type' => $function->returnType ? $function->returnType->toString() : null
        ];
    }

    /**
     * Extrahuj informace o interface
     */
    private function extractInterfaceInfo(Node\Stmt\Interface_ $interface): array
    {
        $methods = [];
        foreach ($interface->stmts as $stmt) {
            if ($stmt instanceof Node\Stmt\ClassMethod) {
                $methods[] = [
                    'name' => $stmt->name->toString(),
                    'parameters' => $this->extractParameters($stmt->params),
                    'return_type' => $stmt->returnType ? $stmt->returnType->toString() : null
                ];
            }
        }

        return [
            'name' => $interface->name->toString(),
            'methods' => $methods,
            'extends' => array_map(fn($e) => $e->toString(), $interface->extends)
        ];
    }

    /**
     * Extrahuj informace o trait
     */
    private function extractTraitInfo(Node\Stmt\Trait_ $trait): array
    {
        $methods = [];
        foreach ($trait->stmts as $stmt) {
            if ($stmt instanceof Node\Stmt\ClassMethod) {
                $methods[] = [
                    'name' => $stmt->name->toString(),
                    'visibility' => $this->getVisibility($stmt),
                    'parameters' => $this->extractParameters($stmt->params),
                    'return_type' => $stmt->returnType ? $stmt->returnType->toString() : null
                ];
            }
        }

        return [
            'name' => $trait->name->toString(),
            'methods' => $methods
        ];
    }

    /**
     * Získej viditelnost metody/vlastnosti
     */
    private function getVisibility($node): string
    {
        if ($node->isPublic()) return 'public';
        if ($node->isProtected()) return 'protected';
        if ($node->isPrivate()) return 'private';
        return 'public'; // default
    }

    /**
     * Extrahuj parametry funkce/metody
     */
    private function extractParameters(array $params): array
    {
        $parameters = [];
        foreach ($params as $param) {
            $parameters[] = [
                'name' => $param->var->name,
                'type' => $param->type ? $param->type->toString() : null,
                'default' => $param->default !== null
            ];
        }
        return $parameters;
    }

    /**
     * Najdi třídu podle jména
     */
    private function findClassByName(array $classes, string $name): ?array
    {
        foreach ($classes as $class) {
            if ($class['name'] === $name) {
                return $class;
            }
        }
        return null;
    }

    /**
     * Zkontroluj změny ve veřejných metodách
     */
    private function hasPublicMethodChanges(array $oldMethods, array $newMethods): bool
    {
        $oldPublicMethods = array_filter($oldMethods, fn($m) => $m['visibility'] === 'public');
        $newPublicMethods = array_filter($newMethods, fn($m) => $m['visibility'] === 'public');

        return count($oldPublicMethods) !== count($newPublicMethods);
    }

    /**
     * Zkontroluj zda element existuje ve struktuře
     */
    private function elementExistsInStructure(array $element, array $structure): bool
    {
        $type = $element['type'];
        $name = $element['name'];

        switch ($type) {
            case 'class':
                return $this->findClassByName($structure['classes'] ?? [], $name) !== null;
            case 'function':
                foreach ($structure['functions'] ?? [] as $func) {
                    if ($func['name'] === $name) return true;
                }
                return false;
            default:
                return true; // Neznámý typ - předpokládej že existuje
        }
    }
}
</file>

<file path="src/Schema/DocumentationSchema.php">
<?php

namespace Digihood\Digidocs\Schema;

use NeuronAI\StructuredOutput\SchemaProperty;

/**
 * Schema pro strukturovaný výstup dokumentace z AI agenta
 */
class DocumentationSchema
{
    #[SchemaProperty(description: 'Název souboru nebo hlavní komponenty')]
    public string $title;

    #[SchemaProperty(description: 'Stručný popis účelu a funkce souboru')]
    public string $overview;

    #[SchemaProperty(description: 'Seznam sekcí dokumentace - každá sekce má title (string) a content (string), volitelně methods, properties, code_examples (arrays)')]
    public array $sections;

    /**
     * Převede strukturovaný výstup na Markdown
     */
    public function toMarkdown(): string
    {
        $markdown = "# {$this->title}\n\n";
        $markdown .= "{$this->overview}\n\n";

        foreach ($this->sections as $section) {
            if (isset($section['title'])) {
                $markdown .= "## {$section['title']}\n\n";
            }

            if (isset($section['content'])) {
                $markdown .= "{$section['content']}\n\n";
            }

            // Zpracuj metody pokud existují
            if (isset($section['methods']) && is_array($section['methods'])) {
                foreach ($section['methods'] as $method) {
                    if (isset($method['name'])) {
                        $markdown .= "### {$method['name']}()\n\n";
                    }
                    if (isset($method['description'])) {
                        $markdown .= "{$method['description']}\n\n";
                    }
                    if (isset($method['parameters'])) {
                        $markdown .= "**Parametry:** {$method['parameters']}\n\n";
                    }
                    if (isset($method['returns'])) {
                        $markdown .= "**Návratová hodnota:** {$method['returns']}\n\n";
                    }
                    if (isset($method['example'])) {
                        $markdown .= "**Příklad použití:**\n```php\n{$method['example']}\n```\n\n";
                    }
                }
            }

            // Zpracuj vlastnosti pokud existují
            if (isset($section['properties']) && is_array($section['properties'])) {
                foreach ($section['properties'] as $property) {
                    if (isset($property['name'])) {
                        $markdown .= "### \${$property['name']}\n\n";
                    }
                    if (isset($property['description'])) {
                        $markdown .= "{$property['description']}\n\n";
                    }
                    if (isset($property['type'])) {
                        $markdown .= "**Typ:** {$property['type']}\n\n";
                    }
                }
            }

            // Zpracuj příklady kódu pokud existují
            if (isset($section['code_examples']) && is_array($section['code_examples'])) {
                foreach ($section['code_examples'] as $example) {
                    if (isset($example['title'])) {
                        $markdown .= "### {$example['title']}\n\n";
                    }
                    if (isset($example['description'])) {
                        $markdown .= "{$example['description']}\n\n";
                    }
                    if (isset($example['code'])) {
                        $markdown .= "```php\n{$example['code']}\n```\n\n";
                    }
                }
            }
        }

        return $markdown;
    }
}

/**
 * Schema pro sekci dokumentace
 */
class DocumentationSection
{
    #[SchemaProperty(description: 'Název sekce')]
    public string $title;

    #[SchemaProperty(description: 'Obsah sekce v Markdown formátu')]
    public string $content;

    #[SchemaProperty(description: 'Seznam metod v této sekci (volitelné)')]
    public ?array $methods = null;

    #[SchemaProperty(description: 'Seznam vlastností v této sekci (volitelné)')]
    public ?array $properties = null;

    #[SchemaProperty(description: 'Příklady kódu pro tuto sekci (volitelné)')]
    public ?array $code_examples = null;
}

/**
 * Schema pro metodu
 */
class MethodSchema
{
    #[SchemaProperty(description: 'Název metody')]
    public string $name;

    #[SchemaProperty(description: 'Popis funkce metody')]
    public string $description;

    #[SchemaProperty(description: 'Popis parametrů metody')]
    public ?string $parameters = null;

    #[SchemaProperty(description: 'Popis návratové hodnoty')]
    public ?string $returns = null;

    #[SchemaProperty(description: 'Příklad použití metody')]
    public ?string $example = null;

    #[SchemaProperty(description: 'Viditelnost metody (public, private, protected)')]
    public ?string $visibility = 'public';
}

/**
 * Schema pro vlastnost
 */
class PropertySchema
{
    #[SchemaProperty(description: 'Název vlastnosti')]
    public string $name;

    #[SchemaProperty(description: 'Popis vlastnosti')]
    public string $description;

    #[SchemaProperty(description: 'Typ vlastnosti')]
    public ?string $type = null;

    #[SchemaProperty(description: 'Viditelnost vlastnosti (public, private, protected)')]
    public ?string $visibility = 'public';

    #[SchemaProperty(description: 'Výchozí hodnota vlastnosti')]
    public ?string $default_value = null;
}

/**
 * Schema pro příklad kódu
 */
class CodeExampleSchema
{
    #[SchemaProperty(description: 'Název příkladu')]
    public string $title;

    #[SchemaProperty(description: 'Popis příkladu')]
    public ?string $description = null;

    #[SchemaProperty(description: 'Kód příkladu')]
    public string $code;

    #[SchemaProperty(description: 'Výstup nebo výsledek příkladu')]
    public ?string $output = null;
}
</file>

<file path="src/Schema/SimpleDocumentationSchema.php">
<?php

namespace Digihood\Digidocs\Schema;

use NeuronAI\StructuredOutput\SchemaProperty;

/**
 * Jednoduchá schema pro strukturovaný výstup dokumentace
 */
class SimpleDocumentationSchema
{
    #[SchemaProperty(description: 'Název souboru nebo hlavní komponenty')]
    public string $title;

    #[SchemaProperty(description: 'Stručný popis účelu a funkce souboru')]
    public string $overview;

    #[SchemaProperty(description: 'Detailní popis tříd a jejich zodpovědností')]
    public string $classes_description;

    #[SchemaProperty(description: 'Dokumentace veřejných metod s parametry a návratovými hodnotami')]
    public string $methods_documentation;

    #[SchemaProperty(description: 'Popis veřejných vlastností a konstant')]
    public string $properties_description;

    #[SchemaProperty(description: 'Laravel-specifické funkcionality (relationships, scopes, middleware, atd.)')]
    public string $laravel_features;

    #[SchemaProperty(description: 'Praktické příklady použití s kódem')]
    public string $usage_examples;

    #[SchemaProperty(description: 'Závislosti a vztahy s dalšími částmi aplikace')]
    public string $dependencies;

    /**
     * Převede strukturovaný výstup na Markdown
     */
    public function toMarkdown(): string
    {
        $markdown = "# {$this->title}\n\n";
        $markdown .= "{$this->overview}\n\n";

        if (!empty($this->classes_description)) {
            $markdown .= "## Třídy a jejich zodpovědnosti\n\n";
            $markdown .= "{$this->classes_description}\n\n";
        }

        if (!empty($this->methods_documentation)) {
            $markdown .= "## Veřejné metody\n\n";
            $markdown .= "{$this->methods_documentation}\n\n";
        }

        if (!empty($this->properties_description)) {
            $markdown .= "## Vlastnosti a konstanty\n\n";
            $markdown .= "{$this->properties_description}\n\n";
        }

        if (!empty($this->laravel_features)) {
            $markdown .= "## Laravel funkcionality\n\n";
            $markdown .= "{$this->laravel_features}\n\n";
        }

        if (!empty($this->usage_examples)) {
            $markdown .= "## Příklady použití\n\n";
            $markdown .= "{$this->usage_examples}\n\n";
        }

        if (!empty($this->dependencies)) {
            $markdown .= "## Závislosti a vztahy\n\n";
            $markdown .= "{$this->dependencies}\n\n";
        }

        return $markdown;
    }
}
</file>

<file path="src/Tools/AstCompareTool.php">
<?php

namespace Digihood\Digidocs\Tools;

use NeuronAI\Tools\Tool;
use NeuronAI\Tools\ToolProperty;
use PhpParser\ParserFactory;
use PhpParser\NodeTraverser;
use PhpParser\Error;
use Exception;

class AstCompareTool
{
    public static function make(): Tool
    {
        return Tool::make(
            'compare_ast_structures',
            'Compare Abstract Syntax Trees of two PHP code versions to detect structural changes.'
        )->addProperty(
            new ToolProperty(
                name: 'old_content',
                type: 'string',
                description: 'Content of the old version of PHP code',
                required: true
            )
        )->addProperty(
            new ToolProperty(
                name: 'new_content',
                type: 'string',
                description: 'Content of the new version of PHP code',
                required: true
            )
        )->addProperty(
            new ToolProperty(
                name: 'file_path',
                type: 'string',
                description: 'Path to the file being compared (for context)',
                required: false
            )
        )->setCallable(new AstComparer());
    }
}

class AstComparer
{
    public function __invoke(string $old_content, string $new_content, ?string $file_path = null): array
    {
        try {
            $parser = (new ParserFactory)->create(ParserFactory::PREFER_PHP7);

            // Parse both versions
            $oldAst = $parser->parse($old_content);
            $newAst = $parser->parse($new_content);

            if (!$oldAst || !$newAst) {
                return [
                    'status' => 'error',
                    'error' => 'Failed to parse PHP code',
                    'file_path' => $file_path
                ];
            }

            // Extract structures from both ASTs
            $oldStructure = $this->extractStructure($oldAst);
            $newStructure = $this->extractStructure($newAst);

            // Compare structures
            $comparison = $this->compareStructures($oldStructure, $newStructure);

            return [
                'status' => 'success',
                'file_path' => $file_path,
                'old_structure' => $oldStructure,
                'new_structure' => $newStructure,
                'comparison' => $comparison,
                'has_structural_changes' => $comparison['has_changes'],
                'change_summary' => $this->generateChangeSummary($comparison)
            ];

        } catch (Error $e) {
            return [
                'status' => 'error',
                'error' => 'PHP Parse Error: ' . $e->getMessage(),
                'file_path' => $file_path
            ];
        } catch (Exception $e) {
            return [
                'status' => 'error',
                'error' => $e->getMessage(),
                'file_path' => $file_path
            ];
        }
    }

    /**
     * Extrahuje strukturu z AST
     */
    private function extractStructure(array $ast): array
    {
        $structure = [
            'namespace' => null,
            'uses' => [],
            'classes' => [],
            'interfaces' => [],
            'traits' => [],
            'functions' => [],
            'constants' => []
        ];

        $this->traverseNodes($ast, $structure);

        return $structure;
    }

    /**
     * Prochází AST uzly a extrahuje strukturu
     */
    private function traverseNodes(array $nodes, array &$structure, string $currentClass = null): void
    {
        foreach ($nodes as $node) {
            if (!is_object($node)) {
                continue;
            }

            $nodeType = $node->getType();

            switch ($nodeType) {
                case 'Stmt_Namespace':
                    $structure['namespace'] = $node->name ? $node->name->toString() : null;
                    if ($node->stmts) {
                        $this->traverseNodes($node->stmts, $structure, $currentClass);
                    }
                    break;

                case 'Stmt_Use':
                    foreach ($node->uses as $use) {
                        $structure['uses'][] = $use->name->toString();
                    }
                    break;

                case 'Stmt_Class':
                    $className = $node->name->toString();
                    $classInfo = [
                        'name' => $className,
                        'extends' => $node->extends ? $node->extends->toString() : null,
                        'implements' => [],
                        'methods' => [],
                        'properties' => [],
                        'constants' => [],
                        'is_abstract' => $node->isAbstract(),
                        'is_final' => $node->isFinal()
                    ];

                    if ($node->implements) {
                        foreach ($node->implements as $implement) {
                            $classInfo['implements'][] = $implement->toString();
                        }
                    }

                    $this->extractClassMembers($node->stmts, $classInfo);
                    $structure['classes'][$className] = $classInfo;
                    break;

                case 'Stmt_Interface':
                    $interfaceName = $node->name->toString();
                    $interfaceInfo = [
                        'name' => $interfaceName,
                        'extends' => [],
                        'methods' => [],
                        'constants' => []
                    ];

                    if ($node->extends) {
                        foreach ($node->extends as $extend) {
                            $interfaceInfo['extends'][] = $extend->toString();
                        }
                    }

                    $this->extractClassMembers($node->stmts, $interfaceInfo);
                    $structure['interfaces'][$interfaceName] = $interfaceInfo;
                    break;

                case 'Stmt_Trait':
                    $traitName = $node->name->toString();
                    $traitInfo = [
                        'name' => $traitName,
                        'methods' => [],
                        'properties' => []
                    ];

                    $this->extractClassMembers($node->stmts, $traitInfo);
                    $structure['traits'][$traitName] = $traitInfo;
                    break;

                case 'Stmt_Function':
                    $functionInfo = [
                        'name' => $node->name->toString(),
                        'parameters' => $this->extractParameters($node->params),
                        'return_type' => $node->returnType ? $this->getTypeString($node->returnType) : null,
                        'is_reference' => $node->byRef
                    ];
                    $structure['functions'][] = $functionInfo;
                    break;

                case 'Stmt_Const':
                    foreach ($node->consts as $const) {
                        $structure['constants'][] = [
                            'name' => $const->name->toString(),
                            'value' => $this->getValueString($const->value)
                        ];
                    }
                    break;
            }
        }
    }

    /**
     * Extrahuje členy třídy (metody, vlastnosti, konstanty)
     */
    private function extractClassMembers(array $stmts, array &$classInfo): void
    {
        foreach ($stmts as $stmt) {
            if (!is_object($stmt)) {
                continue;
            }

            switch ($stmt->getType()) {
                case 'Stmt_ClassMethod':
                    $methodInfo = [
                        'name' => $stmt->name->toString(),
                        'visibility' => $this->getVisibility($stmt),
                        'is_static' => $stmt->isStatic(),
                        'is_abstract' => $stmt->isAbstract(),
                        'is_final' => $stmt->isFinal(),
                        'parameters' => $this->extractParameters($stmt->params),
                        'return_type' => $stmt->returnType ? $this->getTypeString($stmt->returnType) : null
                    ];
                    $classInfo['methods'][] = $methodInfo;
                    break;

                case 'Stmt_Property':
                    foreach ($stmt->props as $prop) {
                        $propertyInfo = [
                            'name' => $prop->name->toString(),
                            'visibility' => $this->getVisibility($stmt),
                            'is_static' => $stmt->isStatic(),
                            'type' => $stmt->type ? $this->getTypeString($stmt->type) : null,
                            'default' => $prop->default ? $this->getValueString($prop->default) : null
                        ];
                        $classInfo['properties'][] = $propertyInfo;
                    }
                    break;

                case 'Stmt_ClassConst':
                    foreach ($stmt->consts as $const) {
                        $constantInfo = [
                            'name' => $const->name->toString(),
                            'visibility' => $this->getVisibility($stmt),
                            'value' => $this->getValueString($const->value)
                        ];
                        $classInfo['constants'][] = $constantInfo;
                    }
                    break;
            }
        }
    }

    /**
     * Extrahuje parametry funkce/metody
     */
    private function extractParameters(array $params): array
    {
        $parameters = [];

        foreach ($params as $param) {
            $paramInfo = [
                'name' => $param->var->name,
                'type' => $param->type ? $this->getTypeString($param->type) : null,
                'default' => $param->default ? $this->getValueString($param->default) : null,
                'is_reference' => $param->byRef,
                'is_variadic' => $param->variadic
            ];
            $parameters[] = $paramInfo;
        }

        return $parameters;
    }

    /**
     * Získá viditelnost (public, private, protected)
     */
    private function getVisibility($node): string
    {
        if ($node->isPublic()) return 'public';
        if ($node->isPrivate()) return 'private';
        if ($node->isProtected()) return 'protected';
        return 'public'; // default
    }

    /**
     * Převede typ na string
     */
    private function getTypeString($type): string
    {
        if (is_string($type)) {
            return $type;
        }

        if (method_exists($type, 'toString')) {
            return $type->toString();
        }

        if (isset($type->name)) {
            return $type->name;
        }

        return 'mixed';
    }

    /**
     * Převede hodnotu na string
     */
    private function getValueString($value): string
    {
        if (is_null($value)) {
            return 'null';
        }

        if (method_exists($value, 'toString')) {
            return $value->toString();
        }

        return 'unknown';
    }

    /**
     * Porovná dvě struktury a najde rozdíly
     */
    private function compareStructures(array $oldStructure, array $newStructure): array
    {
        $comparison = [
            'has_changes' => false,
            'namespace_changed' => $oldStructure['namespace'] !== $newStructure['namespace'],
            'uses_changes' => $this->compareArrays($oldStructure['uses'], $newStructure['uses']),
            'classes_changes' => $this->compareClasses($oldStructure['classes'], $newStructure['classes']),
            'interfaces_changes' => $this->compareInterfaces($oldStructure['interfaces'], $newStructure['interfaces']),
            'traits_changes' => $this->compareTraits($oldStructure['traits'], $newStructure['traits']),
            'functions_changes' => $this->compareFunctions($oldStructure['functions'], $newStructure['functions']),
            'constants_changes' => $this->compareConstants($oldStructure['constants'], $newStructure['constants'])
        ];

        // Zkontroluj jestli jsou nějaké změny
        $comparison['has_changes'] = $comparison['namespace_changed'] ||
                                   $comparison['uses_changes']['has_changes'] ||
                                   $comparison['classes_changes']['has_changes'] ||
                                   $comparison['interfaces_changes']['has_changes'] ||
                                   $comparison['traits_changes']['has_changes'] ||
                                   $comparison['functions_changes']['has_changes'] ||
                                   $comparison['constants_changes']['has_changes'];

        return $comparison;
    }

    /**
     * Porovná pole hodnot
     */
    private function compareArrays(array $old, array $new): array
    {
        $added = array_diff($new, $old);
        $removed = array_diff($old, $new);

        return [
            'has_changes' => !empty($added) || !empty($removed),
            'added' => array_values($added),
            'removed' => array_values($removed)
        ];
    }

    /**
     * Porovná třídy
     */
    private function compareClasses(array $oldClasses, array $newClasses): array
    {
        $changes = [
            'has_changes' => false,
            'added' => [],
            'removed' => [],
            'modified' => []
        ];

        // Najdi přidané a odebrané třídy
        $oldNames = array_keys($oldClasses);
        $newNames = array_keys($newClasses);

        $changes['added'] = array_diff($newNames, $oldNames);
        $changes['removed'] = array_diff($oldNames, $newNames);

        // Porovnej existující třídy
        $common = array_intersect($oldNames, $newNames);
        foreach ($common as $className) {
            $classChanges = $this->compareClass($oldClasses[$className], $newClasses[$className]);
            if ($classChanges['has_changes']) {
                $changes['modified'][$className] = $classChanges;
            }
        }

        $changes['has_changes'] = !empty($changes['added']) ||
                                !empty($changes['removed']) ||
                                !empty($changes['modified']);

        return $changes;
    }

    /**
     * Porovná jednu třídu
     */
    private function compareClass(array $oldClass, array $newClass): array
    {
        $changes = [
            'has_changes' => false,
            'extends_changed' => $oldClass['extends'] !== $newClass['extends'],
            'implements_changes' => $this->compareArrays($oldClass['implements'], $newClass['implements']),
            'methods_changes' => $this->compareMethods($oldClass['methods'], $newClass['methods']),
            'properties_changes' => $this->compareProperties($oldClass['properties'], $newClass['properties']),
            'constants_changes' => $this->compareConstants($oldClass['constants'], $newClass['constants']),
            'modifiers_changed' => [
                'abstract' => $oldClass['is_abstract'] !== $newClass['is_abstract'],
                'final' => $oldClass['is_final'] !== $newClass['is_final']
            ]
        ];

        $changes['has_changes'] = $changes['extends_changed'] ||
                                $changes['implements_changes']['has_changes'] ||
                                $changes['methods_changes']['has_changes'] ||
                                $changes['properties_changes']['has_changes'] ||
                                $changes['constants_changes']['has_changes'] ||
                                $changes['modifiers_changed']['abstract'] ||
                                $changes['modifiers_changed']['final'];

        return $changes;
    }

    /**
     * Porovná metody
     */
    private function compareMethods(array $oldMethods, array $newMethods): array
    {
        $changes = [
            'has_changes' => false,
            'added' => [],
            'removed' => [],
            'modified' => []
        ];

        // Vytvoř mapy podle jmen metod
        $oldMap = [];
        $newMap = [];

        foreach ($oldMethods as $method) {
            $oldMap[$method['name']] = $method;
        }

        foreach ($newMethods as $method) {
            $newMap[$method['name']] = $method;
        }

        $oldNames = array_keys($oldMap);
        $newNames = array_keys($newMap);

        $changes['added'] = array_diff($newNames, $oldNames);
        $changes['removed'] = array_diff($oldNames, $newNames);

        // Porovnej existující metody
        $common = array_intersect($oldNames, $newNames);
        foreach ($common as $methodName) {
            if ($this->methodsAreDifferent($oldMap[$methodName], $newMap[$methodName])) {
                $changes['modified'][] = $methodName;
            }
        }

        $changes['has_changes'] = !empty($changes['added']) ||
                                !empty($changes['removed']) ||
                                !empty($changes['modified']);

        return $changes;
    }

    /**
     * Kontroluje jestli se metody liší
     */
    private function methodsAreDifferent(array $oldMethod, array $newMethod): bool
    {
        return $oldMethod['visibility'] !== $newMethod['visibility'] ||
               $oldMethod['is_static'] !== $newMethod['is_static'] ||
               $oldMethod['is_abstract'] !== $newMethod['is_abstract'] ||
               $oldMethod['is_final'] !== $newMethod['is_final'] ||
               $oldMethod['return_type'] !== $newMethod['return_type'] ||
               $this->parametersAreDifferent($oldMethod['parameters'], $newMethod['parameters']);
    }

    /**
     * Kontroluje jestli se parametry liší
     */
    private function parametersAreDifferent(array $oldParams, array $newParams): bool
    {
        if (count($oldParams) !== count($newParams)) {
            return true;
        }

        for ($i = 0; $i < count($oldParams); $i++) {
            $old = $oldParams[$i];
            $new = $newParams[$i];

            if ($old['name'] !== $new['name'] ||
                $old['type'] !== $new['type'] ||
                $old['default'] !== $new['default'] ||
                $old['is_reference'] !== $new['is_reference'] ||
                $old['is_variadic'] !== $new['is_variadic']) {
                return true;
            }
        }

        return false;
    }

    /**
     * Porovná vlastnosti
     */
    private function compareProperties(array $oldProperties, array $newProperties): array
    {
        // Podobná logika jako u metod
        $changes = [
            'has_changes' => false,
            'added' => [],
            'removed' => [],
            'modified' => []
        ];

        $oldMap = [];
        $newMap = [];

        foreach ($oldProperties as $prop) {
            $oldMap[$prop['name']] = $prop;
        }

        foreach ($newProperties as $prop) {
            $newMap[$prop['name']] = $prop;
        }

        $oldNames = array_keys($oldMap);
        $newNames = array_keys($newMap);

        $changes['added'] = array_diff($newNames, $oldNames);
        $changes['removed'] = array_diff($oldNames, $newNames);

        $common = array_intersect($oldNames, $newNames);
        foreach ($common as $propName) {
            if ($this->propertiesAreDifferent($oldMap[$propName], $newMap[$propName])) {
                $changes['modified'][] = $propName;
            }
        }

        $changes['has_changes'] = !empty($changes['added']) ||
                                !empty($changes['removed']) ||
                                !empty($changes['modified']);

        return $changes;
    }

    /**
     * Kontroluje jestli se vlastnosti liší
     */
    private function propertiesAreDifferent(array $oldProp, array $newProp): bool
    {
        return $oldProp['visibility'] !== $newProp['visibility'] ||
               $oldProp['is_static'] !== $newProp['is_static'] ||
               $oldProp['type'] !== $newProp['type'] ||
               $oldProp['default'] !== $newProp['default'];
    }

    /**
     * Porovná rozhraní
     */
    private function compareInterfaces(array $oldInterfaces, array $newInterfaces): array
    {
        // Podobná logika jako u tříd, ale jednodušší
        return $this->compareClasses($oldInterfaces, $newInterfaces);
    }

    /**
     * Porovná traity
     */
    private function compareTraits(array $oldTraits, array $newTraits): array
    {
        // Podobná logika jako u tříd, ale jednodušší
        return $this->compareClasses($oldTraits, $newTraits);
    }

    /**
     * Porovná funkce
     */
    private function compareFunctions(array $oldFunctions, array $newFunctions): array
    {
        return $this->compareMethods($oldFunctions, $newFunctions);
    }

    /**
     * Porovná konstanty
     */
    private function compareConstants(array $oldConstants, array $newConstants): array
    {
        return $this->compareProperties($oldConstants, $newConstants);
    }

    /**
     * Generuje shrnutí změn
     */
    private function generateChangeSummary(array $comparison): array
    {
        $summary = [
            'total_changes' => 0,
            'change_types' => [],
            'severity' => 'none'
        ];

        if ($comparison['namespace_changed']) {
            $summary['change_types'][] = 'namespace';
            $summary['total_changes']++;
        }

        if ($comparison['uses_changes']['has_changes']) {
            $summary['change_types'][] = 'imports';
            $summary['total_changes']++;
        }

        if ($comparison['classes_changes']['has_changes']) {
            $summary['change_types'][] = 'classes';
            $summary['total_changes']++;
        }

        if ($comparison['interfaces_changes']['has_changes']) {
            $summary['change_types'][] = 'interfaces';
            $summary['total_changes']++;
        }

        if ($comparison['traits_changes']['has_changes']) {
            $summary['change_types'][] = 'traits';
            $summary['total_changes']++;
        }

        if ($comparison['functions_changes']['has_changes']) {
            $summary['change_types'][] = 'functions';
            $summary['total_changes']++;
        }

        if ($comparison['constants_changes']['has_changes']) {
            $summary['change_types'][] = 'constants';
            $summary['total_changes']++;
        }

        // Určení závažnosti
        if ($summary['total_changes'] === 0) {
            $summary['severity'] = 'none';
        } elseif (in_array('classes', $summary['change_types']) ||
                  in_array('interfaces', $summary['change_types']) ||
                  in_array('functions', $summary['change_types'])) {
            $summary['severity'] = 'major';
        } elseif (in_array('imports', $summary['change_types']) ||
                  in_array('constants', $summary['change_types'])) {
            $summary['severity'] = 'minor';
        } else {
            $summary['severity'] = 'minimal';
        }

        return $summary;
    }
}
</file>

<file path="src/Tools/CodeAnalyzerTool.php">
<?php

namespace Digihood\Digidocs\Tools;

use NeuronAI\Tools\Tool;
use NeuronAI\Tools\ToolProperty;
use Digihood\Digidocs\Services\CodeVisitor;
use PhpParser\ParserFactory;
use PhpParser\NodeTraverser;
use PhpParser\Error;
use Exception;

class CodeAnalyzerTool
{
    public static function make(): Tool
    {
        return Tool::make(
            'analyze_php_code',
            'Analyze PHP file structure, extract classes, methods, and existing documentation.'
        )->addProperty(
            new ToolProperty(
                name: 'file_path',
                type: 'string',
                description: 'Path to the PHP file to analyze',
                required: true
            )
        )->addProperty(
            new ToolProperty(
                name: 'include_context',
                type: 'boolean',
                description: 'Whether to include Laravel context (routes, models, etc.)',
                required: false
            )
        )->setCallable(new CodeAnalyzer());
    }
}

class CodeAnalyzer
{
    public function __invoke(string $file_path, bool $include_context = true): array
    {
        $fullPath = base_path($file_path);

        if (!file_exists($fullPath)) {
            return [
                'status' => 'error',
                'error' => 'File not found',
                'file_path' => $file_path
            ];
        }

        $content = file_get_contents($fullPath);

        if ($content === false) {
            return [
                'status' => 'error',
                'error' => 'Could not read file',
                'file_path' => $file_path
            ];
        }

        $parser = (new ParserFactory)->createForNewestSupportedVersion();

        try {
            $ast = $parser->parse($content);
            $visitor = new CodeVisitor();
            $traverser = new NodeTraverser();
            $traverser->addVisitor($visitor);
            $traverser->traverse($ast);

            $analysis = [
                'status' => 'success',
                'file_path' => $file_path,
                'file_size' => filesize($fullPath),
                'lines_count' => substr_count($content, "\n") + 1,
                'namespace' => $visitor->getNamespace(),
                'classes' => $visitor->getClasses(),
                'methods' => $visitor->getMethods(),
                'properties' => $visitor->getProperties(),
                'imports' => $visitor->getImports(),
                'existing_docs' => $visitor->getExistingDocs(),
                'file_content_preview' => $this->getContentPreview($content)
            ];

            if ($include_context) {
                $analysis['laravel_context'] = $this->getLaravelContext($file_path, $analysis);
            }

            return $analysis;

        } catch (Error $e) {
            return [
                'status' => 'error',
                'error' => 'Parse error: ' . $e->getMessage(),
                'file_path' => $file_path,
                'line' => $e->getStartLine()
            ];
        } catch (Exception $e) {
            return [
                'status' => 'error',
                'error' => 'Analysis error: ' . $e->getMessage(),
                'file_path' => $file_path
            ];
        }
    }

    /**
     * Získá Laravel kontext pro soubor
     */
    private function getLaravelContext(string $filePath, array $analysis): array
    {
        $context = [
            'type' => 'unknown',
            'framework_features' => []
        ];

        // Detekce typu souboru podle cesty
        if (str_contains($filePath, 'Controllers/')) {
            $context['type'] = 'controller';
            $context['framework_features'] = $this->getControllerFeatures($analysis);
        } elseif (str_contains($filePath, 'Models/')) {
            $context['type'] = 'model';
            $context['framework_features'] = $this->getModelFeatures($analysis);
        } elseif (str_contains($filePath, 'Middleware/')) {
            $context['type'] = 'middleware';
            $context['framework_features'] = $this->getMiddlewareFeatures($analysis);
        } elseif (str_contains($filePath, 'Commands/')) {
            $context['type'] = 'command';
            $context['framework_features'] = $this->getCommandFeatures($analysis);
        } elseif (str_contains($filePath, 'Jobs/')) {
            $context['type'] = 'job';
            $context['framework_features'] = $this->getJobFeatures($analysis);
        } elseif (str_contains($filePath, 'Providers/')) {
            $context['type'] = 'service_provider';
            $context['framework_features'] = $this->getServiceProviderFeatures($analysis);
        }

        return $context;
    }

    private function getControllerFeatures(array $analysis): array
    {
        $features = [];

        // Zkontroluj extends
        foreach ($analysis['classes'] as $class) {
            if ($class['extends']) {
                $features[] = "Extends: {$class['extends']}";
            }
        }

        // Zkontroluj metody
        $actionMethods = array_filter($analysis['methods'], function($method) {
            return $method['is_public'] && !in_array($method['name'], ['__construct', '__destruct']);
        });

        if (!empty($actionMethods)) {
            $features[] = "Actions: " . implode(', ', array_column($actionMethods, 'name'));
        }

        return $features;
    }

    private function getModelFeatures(array $analysis): array
    {
        $features = [];

        // Zkontroluj extends (obvykle Model nebo Eloquent)
        foreach ($analysis['classes'] as $class) {
            if ($class['extends']) {
                $features[] = "Extends: {$class['extends']}";
            }
        }

        // Zkontroluj properties (fillable, guarded, etc.)
        $modelProperties = array_filter($analysis['properties'], function($prop) {
            return in_array($prop['name'], ['fillable', 'guarded', 'hidden', 'casts', 'dates']);
        });

        foreach ($modelProperties as $prop) {
            $features[] = "Property: {$prop['name']}";
        }

        return $features;
    }

    private function getMiddlewareFeatures(array $analysis): array
    {
        $features = [];

        // Zkontroluj handle metodu
        $handleMethod = array_filter($analysis['methods'], fn($m) => $m['name'] === 'handle');
        if (!empty($handleMethod)) {
            $features[] = "Has handle method";
        }

        return $features;
    }

    private function getCommandFeatures(array $analysis): array
    {
        $features = [];

        // Zkontroluj signature a description properties
        $commandProps = array_filter($analysis['properties'], function($prop) {
            return in_array($prop['name'], ['signature', 'description']);
        });

        foreach ($commandProps as $prop) {
            $features[] = "Property: {$prop['name']}";
        }

        // Zkontroluj handle metodu
        $handleMethod = array_filter($analysis['methods'], fn($m) => $m['name'] === 'handle');
        if (!empty($handleMethod)) {
            $features[] = "Has handle method";
        }

        return $features;
    }

    private function getJobFeatures(array $analysis): array
    {
        $features = [];

        // Zkontroluj implements
        foreach ($analysis['classes'] as $class) {
            if (!empty($class['implements'])) {
                $features[] = "Implements: " . implode(', ', $class['implements']);
            }
        }

        // Zkontroluj handle metodu
        $handleMethod = array_filter($analysis['methods'], fn($m) => $m['name'] === 'handle');
        if (!empty($handleMethod)) {
            $features[] = "Has handle method";
        }

        return $features;
    }

    private function getServiceProviderFeatures(array $analysis): array
    {
        $features = [];

        // Zkontroluj boot a register metody
        $bootMethod = array_filter($analysis['methods'], fn($m) => $m['name'] === 'boot');
        $registerMethod = array_filter($analysis['methods'], fn($m) => $m['name'] === 'register');

        if (!empty($bootMethod)) {
            $features[] = "Has boot method";
        }

        if (!empty($registerMethod)) {
            $features[] = "Has register method";
        }

        return $features;
    }

    /**
     * Získá náhled obsahu souboru (první a poslední řádky)
     */
    private function getContentPreview(string $content): array
    {
        $lines = explode("\n", $content);
        $totalLines = count($lines);

        $preview = [
            'total_lines' => $totalLines,
            'first_lines' => array_slice($lines, 0, min(5, $totalLines)),
            'last_lines' => $totalLines > 10 ? array_slice($lines, -5) : []
        ];

        return $preview;
    }
}
</file>

<file path="src/Tools/CodeDiffTool.php">
<?php

namespace Digihood\Digidocs\Tools;

use NeuronAI\Tools\Tool;
use NeuronAI\Tools\ToolProperty;
use Exception;

class CodeDiffTool
{
    public static function make(): Tool
    {
        return Tool::make(
            'analyze_code_diff',
            'Compare two versions of a file and analyze the differences between them.'
        )->addProperty(
            new ToolProperty(
                name: 'file_path',
                type: 'string',
                description: 'Path to the file to analyze',
                required: true
            )
        )->addProperty(
            new ToolProperty(
                name: 'old_hash',
                type: 'string',
                description: 'Hash of the old version (for Git comparison)',
                required: false
            )
        )->addProperty(
            new ToolProperty(
                name: 'new_hash',
                type: 'string',
                description: 'Hash of the new version (for Git comparison)',
                required: false
            )
        )->addProperty(
            new ToolProperty(
                name: 'old_content',
                type: 'string',
                description: 'Content of the old version (alternative to Git hashes)',
                required: false
            )
        )->addProperty(
            new ToolProperty(
                name: 'new_content',
                type: 'string',
                description: 'Content of the new version (alternative to Git hashes)',
                required: false
            )
        )->setCallable(new CodeDiffAnalyzer());
    }
}

class CodeDiffAnalyzer
{
    public function __invoke(
        string $file_path,
        ?string $old_hash = null,
        ?string $new_hash = null,
        ?string $old_content = null,
        ?string $new_content = null
    ): array {
        try {
            // Získej obsah souborů
            if ($old_content && $new_content) {
                $oldContent = $old_content;
                $newContent = $new_content;
            } elseif ($old_hash && $new_hash) {
                $oldContent = $this->getContentFromGit($file_path, $old_hash);
                $newContent = $this->getContentFromGit($file_path, $new_hash);
            } else {
                // Porovnej s aktuálním souborem
                $fullPath = base_path($file_path);
                if (!file_exists($fullPath)) {
                    return [
                        'status' => 'error',
                        'error' => 'File not found',
                        'file_path' => $file_path
                    ];
                }
                $newContent = file_get_contents($fullPath);
                $oldContent = $old_content ?? '';
            }

            // Analýza rozdílů
            $diff = $this->generateDiff($oldContent, $newContent);
            $analysis = $this->analyzeDifferences($oldContent, $newContent, $diff);

            return [
                'status' => 'success',
                'file_path' => $file_path,
                'diff' => $diff,
                'analysis' => $analysis,
                'old_hash' => $old_hash,
                'new_hash' => $new_hash,
                'statistics' => $this->getStatistics($oldContent, $newContent)
            ];

        } catch (Exception $e) {
            return [
                'status' => 'error',
                'error' => $e->getMessage(),
                'file_path' => $file_path
            ];
        }
    }

    /**
     * Získá obsah souboru z Git commitu
     */
    private function getContentFromGit(string $filePath, string $hash): string
    {
        try {
            $command = "git show {$hash}:{$filePath}";
            $output = shell_exec($command);
            return $output ?: '';
        } catch (Exception $e) {
            return '';
        }
    }

    /**
     * Generuje unified diff
     */
    private function generateDiff(string $oldContent, string $newContent): array
    {
        $oldLines = explode("\n", $oldContent);
        $newLines = explode("\n", $newContent);

        $diff = [];
        $oldIndex = 0;
        $newIndex = 0;

        while ($oldIndex < count($oldLines) || $newIndex < count($newLines)) {
            if ($oldIndex >= count($oldLines)) {
                // Přidané řádky
                $diff[] = [
                    'type' => 'added',
                    'line_number' => $newIndex + 1,
                    'content' => $newLines[$newIndex]
                ];
                $newIndex++;
            } elseif ($newIndex >= count($newLines)) {
                // Smazané řádky
                $diff[] = [
                    'type' => 'removed',
                    'line_number' => $oldIndex + 1,
                    'content' => $oldLines[$oldIndex]
                ];
                $oldIndex++;
            } elseif ($oldLines[$oldIndex] === $newLines[$newIndex]) {
                // Nezměněné řádky
                $diff[] = [
                    'type' => 'unchanged',
                    'old_line' => $oldIndex + 1,
                    'new_line' => $newIndex + 1,
                    'content' => $oldLines[$oldIndex]
                ];
                $oldIndex++;
                $newIndex++;
            } else {
                // Změněné řádky
                $diff[] = [
                    'type' => 'changed',
                    'old_line' => $oldIndex + 1,
                    'new_line' => $newIndex + 1,
                    'old_content' => $oldLines[$oldIndex],
                    'new_content' => $newLines[$newIndex]
                ];
                $oldIndex++;
                $newIndex++;
            }
        }

        return $diff;
    }

    /**
     * Analyzuje typy změn
     */
    private function analyzeDifferences(string $oldContent, string $newContent, array $diff): array
    {
        $analysis = [
            'change_types' => [],
            'affected_lines' => [],
            'whitespace_only' => true,
            'comments_only' => true,
            'structural_changes' => false,
            'semantic_changes' => false
        ];

        $addedLines = 0;
        $removedLines = 0;
        $changedLines = 0;

        foreach ($diff as $change) {
            switch ($change['type']) {
                case 'added':
                    $addedLines++;
                    $analysis['affected_lines'][] = $change['line_number'];
                    if (!$this->isWhitespaceOnly($change['content'])) {
                        $analysis['whitespace_only'] = false;
                    }
                    if (!$this->isCommentOnly($change['content'])) {
                        $analysis['comments_only'] = false;
                    }
                    break;

                case 'removed':
                    $removedLines++;
                    $analysis['affected_lines'][] = $change['line_number'];
                    if (!$this->isWhitespaceOnly($change['content'])) {
                        $analysis['whitespace_only'] = false;
                    }
                    if (!$this->isCommentOnly($change['content'])) {
                        $analysis['comments_only'] = false;
                    }
                    break;

                case 'changed':
                    $changedLines++;
                    $analysis['affected_lines'][] = $change['old_line'];

                    // Kontrola typu změny
                    if (!$this->isWhitespaceChange($change['old_content'], $change['new_content'])) {
                        $analysis['whitespace_only'] = false;
                    }
                    if (!$this->isCommentChange($change['old_content'], $change['new_content'])) {
                        $analysis['comments_only'] = false;
                    }
                    break;
            }
        }

        // Detekce strukturálních změn
        $analysis['structural_changes'] = $this->hasStructuralChanges($oldContent, $newContent);
        $analysis['semantic_changes'] = !$analysis['whitespace_only'] && !$analysis['comments_only'];

        $analysis['change_types'] = [
            'added_lines' => $addedLines,
            'removed_lines' => $removedLines,
            'changed_lines' => $changedLines,
            'total_changes' => $addedLines + $removedLines + $changedLines
        ];

        return $analysis;
    }

    /**
     * Kontroluje jestli je řádek pouze whitespace
     */
    private function isWhitespaceOnly(string $line): bool
    {
        return trim($line) === '';
    }

    /**
     * Kontroluje jestli je řádek pouze komentář
     */
    private function isCommentOnly(string $line): bool
    {
        $trimmed = trim($line);
        return str_starts_with($trimmed, '//') ||
               str_starts_with($trimmed, '#') ||
               str_starts_with($trimmed, '/*') ||
               str_starts_with($trimmed, '*') ||
               str_starts_with($trimmed, '*/');
    }

    /**
     * Kontroluje jestli je změna pouze whitespace
     */
    private function isWhitespaceChange(string $old, string $new): bool
    {
        return trim($old) === trim($new);
    }

    /**
     * Kontroluje jestli je změna pouze v komentářích
     */
    private function isCommentChange(string $old, string $new): bool
    {
        return $this->isCommentOnly($old) && $this->isCommentOnly($new);
    }

    /**
     * Detekuje strukturální změny (třídy, metody, vlastnosti)
     */
    private function hasStructuralChanges(string $oldContent, string $newContent): bool
    {
        // Jednoduché regex patterns pro PHP struktury
        $patterns = [
            '/class\s+\w+/',
            '/interface\s+\w+/',
            '/trait\s+\w+/',
            '/function\s+\w+\s*\(/',
            '/public\s+function\s+\w+/',
            '/private\s+function\s+\w+/',
            '/protected\s+function\s+\w+/',
            '/public\s+\$\w+/',
            '/private\s+\$\w+/',
            '/protected\s+\$\w+/',
            '/const\s+\w+\s*=/',
        ];

        foreach ($patterns as $pattern) {
            $oldMatches = preg_match_all($pattern, $oldContent);
            $newMatches = preg_match_all($pattern, $newContent);

            if ($oldMatches !== $newMatches) {
                return true;
            }
        }

        return false;
    }

    /**
     * Získá statistiky změn
     */
    private function getStatistics(string $oldContent, string $newContent): array
    {
        $oldLines = explode("\n", $oldContent);
        $newLines = explode("\n", $newContent);

        return [
            'old_lines_count' => count($oldLines),
            'new_lines_count' => count($newLines),
            'lines_difference' => count($newLines) - count($oldLines),
            'old_size' => strlen($oldContent),
            'new_size' => strlen($newContent),
            'size_difference' => strlen($newContent) - strlen($oldContent),
            'similarity_ratio' => $this->calculateSimilarity($oldContent, $newContent)
        ];
    }

    /**
     * Vypočítá podobnost mezi dvěma texty
     */
    private function calculateSimilarity(string $old, string $new): float
    {
        if (empty($old) && empty($new)) {
            return 1.0;
        }

        if (empty($old) || empty($new)) {
            return 0.0;
        }

        similar_text($old, $new, $percent);
        return round($percent / 100, 3);
    }
}
</file>

<file path="src/Tools/FileHashTool.php">
<?php

namespace Digihood\Digidocs\Tools;

use NeuronAI\Tools\Tool;
use NeuronAI\Tools\ToolProperty;

class FileHashTool
{
    public static function make(): Tool
    {
        return Tool::make(
            'calculate_file_hash',
            'Calculate hash of files for change detection and tracking.'
        )->addProperty(
            new ToolProperty(
                name: 'file_path',
                type: 'string',
                description: 'Path to the file to calculate hash for',
                required: true
            )
        )->addProperty(
            new ToolProperty(
                name: 'algorithm',
                type: 'string',
                description: 'Hash algorithm to use (sha256, md5, etc.)',
                required: false
            )
        )->setCallable(new FileHashCalculator());
    }
}

class FileHashCalculator
{
    public function __invoke(string $file_path, string $algorithm = 'sha256'): array
    {
        $fullPath = base_path($file_path);

        if (!file_exists($fullPath)) {
            return [
                'status' => 'error',
                'error' => 'File not found',
                'file_path' => $file_path
            ];
        }

        if (!is_readable($fullPath)) {
            return [
                'status' => 'error',
                'error' => 'File is not readable',
                'file_path' => $file_path
            ];
        }

        // Validace algoritmu
        if (!in_array($algorithm, hash_algos())) {
            return [
                'status' => 'error',
                'error' => "Unsupported hash algorithm: {$algorithm}",
                'file_path' => $file_path,
                'supported_algorithms' => $this->getSupportedAlgorithms()
            ];
        }

        try {
            $hash = hash_file($algorithm, $fullPath);

            if ($hash === false) {
                return [
                    'status' => 'error',
                    'error' => 'Failed to calculate hash',
                    'file_path' => $file_path
                ];
            }

            $fileStats = stat($fullPath);

            return [
                'status' => 'success',
                'file_path' => $file_path,
                'hash' => $hash,
                'algorithm' => $algorithm,
                'file_info' => [
                    'size' => $fileStats['size'],
                    'modified_time' => $fileStats['mtime'],
                    'modified_date' => date('Y-m-d H:i:s', $fileStats['mtime']),
                    'permissions' => substr(sprintf('%o', $fileStats['mode']), -4),
                    'is_executable' => is_executable($fullPath),
                    'mime_type' => $this->getMimeType($fullPath)
                ],
                'hash_info' => [
                    'length' => strlen($hash),
                    'created_at' => date('Y-m-d H:i:s')
                ]
            ];

        } catch (\Exception $e) {
            return [
                'status' => 'error',
                'error' => 'Exception occurred: ' . $e->getMessage(),
                'file_path' => $file_path
            ];
        }
    }

    /**
     * Získá seznam podporovaných hash algoritmů
     */
    private function getSupportedAlgorithms(): array
    {
        $common = ['md5', 'sha1', 'sha256', 'sha512'];
        $available = hash_algos();

        return [
            'common' => array_intersect($common, $available),
            'all' => $available
        ];
    }

    /**
     * Získá MIME type souboru
     */
    private function getMimeType(string $filePath): ?string
    {
        if (function_exists('mime_content_type')) {
            return mime_content_type($filePath);
        }

        if (function_exists('finfo_file')) {
            $finfo = finfo_open(FILEINFO_MIME_TYPE);
            if ($finfo) {
                $mimeType = finfo_file($finfo, $filePath);
                finfo_close($finfo);
                return $mimeType ?: null;
            }
        }

        // Fallback based on extension
        $extension = strtolower(pathinfo($filePath, PATHINFO_EXTENSION));

        $mimeTypes = [
            'php' => 'text/x-php',
            'js' => 'text/javascript',
            'css' => 'text/css',
            'html' => 'text/html',
            'txt' => 'text/plain',
            'json' => 'application/json',
            'xml' => 'application/xml',
            'md' => 'text/markdown'
        ];

        return $mimeTypes[$extension] ?? 'application/octet-stream';
    }
}
</file>

<file path="src/Tools/GitAnalyzerTool.php">
<?php

namespace Digihood\Digidocs\Tools;

use NeuronAI\Tools\Tool;
use NeuronAI\Tools\ToolProperty;
use CzProject\GitPhp\Git;
use CzProject\GitPhp\GitRepository;
use Exception;

class GitAnalyzerTool
{
    public static function make(): Tool
    {
        return Tool::make(
            'analyze_git_changes',
            'Analyze Git repository changes to understand what files have been modified.'
        )->addProperty(
            new ToolProperty(
                name: 'since_commit',
                type: 'string',
                description: 'Git commit hash to compare changes from (optional)',
                required: false
            )
        )->addProperty(
            new ToolProperty(
                name: 'file_path',
                type: 'string',
                description: 'Specific file path to analyze (optional)',
                required: false
            )
        )->setCallable(new GitAnalyzer());
    }
}

class GitAnalyzer
{
    public function __invoke(?string $since_commit = null, ?string $file_path = null): array
    {
        try {
            $git = new Git();
            $repo = $git->open(base_path());

            $result = [
                'current_commit' => $this->getCurrentCommit($repo),
                'changed_files' => [],
                'commit_messages' => [],
                'branch' => $this->getCurrentBranch($repo),
                'status' => 'success'
            ];

            if ($since_commit) {
                // Získej změněné soubory
                $changedFiles = $this->getChangedFiles($repo, $since_commit);
                $result['changed_files'] = array_filter(
                    $changedFiles,
                    fn($file) => str_ends_with($file, '.php') && !empty(trim($file))
                );

                // Získej commit zprávy
                $result['commit_messages'] = $this->getCommitMessages($repo, $since_commit);
            }

            if ($file_path && file_exists(base_path($file_path))) {
                $result['file_history'] = $this->getFileHistory($repo, $file_path);
                $result['file_last_modified'] = $this->getFileLastModified($repo, $file_path);
            }

            return $result;

        } catch (Exception $e) {
            return [
                'status' => 'error',
                'error' => $e->getMessage(),
                'changed_files' => [],
                'commit_messages' => []
            ];
        }
    }

    private function getCurrentCommit(GitRepository $repo): ?string
    {
        try {
            // Použiju getLastCommitId() metodu z dokumentace
            $commitId = $repo->getLastCommitId();
            return $commitId ? (string) $commitId : null;
        } catch (Exception $e) {
            return null;
        }
    }

    private function getCurrentBranch(GitRepository $repo): ?string
    {
        try {
            // Použiju getCurrentBranchName() metodu z dokumentace
            return $repo->getCurrentBranchName();
        } catch (Exception $e) {
            return null;
        }
    }

    private function getChangedFiles(GitRepository $repo, string $since_commit): array
    {
        try {
            $output = $repo->execute('diff', '--name-only', "{$since_commit}..HEAD");
            $output = is_array($output) ? implode("\n", $output) : $output;
            return array_filter(
                explode("\n", trim($output)),
                fn($file) => !empty(trim($file))
            );
        } catch (Exception $e) {
            return [];
        }
    }

    private function getCommitMessages(GitRepository $repo, string $since_commit): array
    {
        try {
            $output = $repo->execute('log', '--oneline', '--no-merges', "{$since_commit}..HEAD");
            $output = is_array($output) ? implode("\n", $output) : $output;
            return array_filter(
                explode("\n", trim($output)),
                fn($commit) => !empty(trim($commit))
            );
        } catch (Exception $e) {
            return [];
        }
    }

    private function getFileHistory(GitRepository $repo, string $filePath): array
    {
        try {
            $output = $repo->execute('log', '--oneline', '--no-merges', '-5', $filePath);
            $output = is_array($output) ? implode("\n", $output) : $output;
            return array_filter(
                explode("\n", trim($output)),
                fn($commit) => !empty(trim($commit))
            );
        } catch (Exception $e) {
            return [];
        }
    }

    private function getFileLastModified(GitRepository $repo, string $filePath): ?array
    {
        try {
            $output = $repo->execute('log', '-1', '--pretty=format:%H|%an|%ae|%ad|%s', '--date=iso', $filePath);
            $output = is_array($output) ? implode("\n", $output) : $output;

            if (empty(trim($output))) {
                return null;
            }

            $parts = explode('|', trim($output));
            if (count($parts) >= 5) {
                return [
                    'commit' => $parts[0],
                    'author_name' => $parts[1],
                    'author_email' => $parts[2],
                    'date' => $parts[3],
                    'message' => $parts[4]
                ];
            }

            return null;
        } catch (Exception $e) {
            return null;
        }
    }
}
</file>

<file path="src/Tools/SemanticAnalysisTool.php">
<?php

namespace Digihood\Digidocs\Tools;

use NeuronAI\Tools\Tool;
use NeuronAI\Tools\ToolProperty;
use Exception;

class SemanticAnalysisTool
{
    public static function make(): Tool
    {
        return Tool::make(
            'analyze_semantic_changes',
            'Analyze semantic significance of code changes to determine if documentation update is needed.'
        )->addProperty(
            new ToolProperty(
                name: 'diff_analysis',
                type: 'string',
                description: 'JSON string with output from CodeDiffTool analysis',
                required: true
            )
        )->addProperty(
            new ToolProperty(
                name: 'ast_analysis',
                type: 'string',
                description: 'JSON string with output from AstCompareTool analysis',
                required: true
            )
        )->addProperty(
            new ToolProperty(
                name: 'file_path',
                type: 'string',
                description: 'Path to the file being analyzed',
                required: false
            )
        )->setCallable(new SemanticAnalyzer());
    }
}

class SemanticAnalyzer
{
    public function __invoke(string $diff_analysis, string $ast_analysis, ?string $file_path = null): array
    {
        try {
            // Dekóduj JSON stringy
            $diffData = json_decode($diff_analysis, true);
            $astData = json_decode($ast_analysis, true);

            if (!$diffData || !$astData) {
                return [
                    'status' => 'error',
                    'error' => 'Invalid JSON input data',
                    'file_path' => $file_path
                ];
            }

            // Analýza sémantické významnosti změn
            $semanticScore = $this->calculateSemanticScore($diffData, $astData);
            $changeClassification = $this->classifyChanges($diffData, $astData);
            $recommendation = $this->generateRecommendation($semanticScore, $changeClassification);

            return [
                'status' => 'success',
                'file_path' => $file_path,
                'semantic_score' => $semanticScore,
                'change_classification' => $changeClassification,
                'recommendation' => $recommendation,
                'should_regenerate_docs' => $recommendation['should_regenerate'],
                'confidence' => $recommendation['confidence'],
                'reasoning' => $recommendation['reasoning']
            ];

        } catch (Exception $e) {
            return [
                'status' => 'error',
                'error' => $e->getMessage(),
                'file_path' => $file_path
            ];
        }
    }

    /**
     * Vypočítá sémantické skóre změn (0-100)
     */
    private function calculateSemanticScore(array $diffAnalysis, array $astAnalysis): int
    {
        $score = 0;

        // Skóre z diff analýzy
        if (isset($diffAnalysis['analysis'])) {
            $analysis = $diffAnalysis['analysis'];

            // Strukturální změny = vysoké skóre
            if ($analysis['structural_changes']) {
                $score += 40;
            }

            // Sémantické změny = střední skóre
            if ($analysis['semantic_changes']) {
                $score += 25;
            }

            // Pouze komentáře = nízké skóre
            if ($analysis['comments_only']) {
                $score += 5;
            }

            // Pouze whitespace = minimální skóre
            if ($analysis['whitespace_only']) {
                $score += 1;
            }

            // Počet změn
            $totalChanges = $analysis['change_types']['total_changes'] ?? 0;
            if ($totalChanges > 10) {
                $score += 15;
            } elseif ($totalChanges > 5) {
                $score += 10;
            } elseif ($totalChanges > 1) {
                $score += 5;
            }
        }

        // Skóre z AST analýzy
        if (isset($astAnalysis['comparison'])) {
            $comparison = $astAnalysis['comparison'];

            // Změny v namespace
            if ($comparison['namespace_changed']) {
                $score += 20;
            }

            // Změny v třídách
            if ($comparison['classes_changes']['has_changes']) {
                $score += $this->scoreClassChanges($comparison['classes_changes']);
            }

            // Změny v rozhraních
            if ($comparison['interfaces_changes']['has_changes']) {
                $score += 25;
            }

            // Změny ve funkcích
            if ($comparison['functions_changes']['has_changes']) {
                $score += 20;
            }

            // Změny v importech
            if ($comparison['uses_changes']['has_changes']) {
                $score += 10;
            }
        }

        // Skóre ze shrnutí změn
        if (isset($astAnalysis['change_summary'])) {
            $summary = $astAnalysis['change_summary'];

            switch ($summary['severity']) {
                case 'major':
                    $score += 30;
                    break;
                case 'minor':
                    $score += 15;
                    break;
                case 'minimal':
                    $score += 5;
                    break;
            }
        }

        return min(100, max(0, $score));
    }

    /**
     * Vypočítá skóre pro změny v třídách
     */
    private function scoreClassChanges(array $classChanges): int
    {
        $score = 0;

        // Přidané/odebrané třídy
        $score += count($classChanges['added']) * 15;
        $score += count($classChanges['removed']) * 15;

        // Změněné třídy
        foreach ($classChanges['modified'] as $className => $changes) {
            if ($changes['extends_changed']) {
                $score += 20;
            }

            if ($changes['implements_changes']['has_changes']) {
                $score += 15;
            }

            if ($changes['methods_changes']['has_changes']) {
                $methodChanges = $changes['methods_changes'];
                $score += count($methodChanges['added']) * 10;
                $score += count($methodChanges['removed']) * 10;
                $score += count($methodChanges['modified']) * 8;
            }

            if ($changes['properties_changes']['has_changes']) {
                $propChanges = $changes['properties_changes'];
                $score += count($propChanges['added']) * 5;
                $score += count($propChanges['removed']) * 5;
                $score += count($propChanges['modified']) * 3;
            }

            if ($changes['modifiers_changed']['abstract'] || $changes['modifiers_changed']['final']) {
                $score += 15;
            }
        }

        return $score;
    }

    /**
     * Klasifikuje typy změn
     */
    private function classifyChanges(array $diffAnalysis, array $astAnalysis): array
    {
        $classification = [
            'primary_type' => 'unknown',
            'categories' => [],
            'impact_level' => 'low',
            'documentation_relevance' => 'low'
        ];

        // Analýza z diff
        if (isset($diffAnalysis['analysis'])) {
            $analysis = $diffAnalysis['analysis'];

            if ($analysis['whitespace_only']) {
                $classification['primary_type'] = 'formatting';
                $classification['categories'][] = 'whitespace';
                $classification['impact_level'] = 'none';
                $classification['documentation_relevance'] = 'none';
            } elseif ($analysis['comments_only']) {
                $classification['primary_type'] = 'documentation';
                $classification['categories'][] = 'comments';
                $classification['impact_level'] = 'low';
                $classification['documentation_relevance'] = 'low';
            } elseif ($analysis['structural_changes']) {
                $classification['primary_type'] = 'structural';
                $classification['categories'][] = 'structure';
                $classification['impact_level'] = 'high';
                $classification['documentation_relevance'] = 'high';
            } elseif ($analysis['semantic_changes']) {
                $classification['primary_type'] = 'semantic';
                $classification['categories'][] = 'logic';
                $classification['impact_level'] = 'medium';
                $classification['documentation_relevance'] = 'medium';
            }
        }

        // Analýza z AST
        if (isset($astAnalysis['comparison'])) {
            $comparison = $astAnalysis['comparison'];

            if ($comparison['classes_changes']['has_changes']) {
                $classification['categories'][] = 'classes';
                if ($classification['impact_level'] === 'low') {
                    $classification['impact_level'] = 'medium';
                }
                if ($classification['documentation_relevance'] === 'low') {
                    $classification['documentation_relevance'] = 'medium';
                }
            }

            if ($comparison['interfaces_changes']['has_changes']) {
                $classification['categories'][] = 'interfaces';
                $classification['impact_level'] = 'high';
                $classification['documentation_relevance'] = 'high';
            }

            if ($comparison['functions_changes']['has_changes']) {
                $classification['categories'][] = 'functions';
                if ($classification['impact_level'] !== 'high') {
                    $classification['impact_level'] = 'medium';
                }
                if ($classification['documentation_relevance'] !== 'high') {
                    $classification['documentation_relevance'] = 'medium';
                }
            }

            if ($comparison['namespace_changed']) {
                $classification['categories'][] = 'namespace';
                $classification['impact_level'] = 'high';
                $classification['documentation_relevance'] = 'high';
            }

            if ($comparison['uses_changes']['has_changes']) {
                $classification['categories'][] = 'imports';
            }
        }

        // Určení primárního typu pokud není nastaven
        if ($classification['primary_type'] === 'unknown') {
            if (in_array('classes', $classification['categories']) ||
                in_array('interfaces', $classification['categories'])) {
                $classification['primary_type'] = 'structural';
            } elseif (in_array('functions', $classification['categories'])) {
                $classification['primary_type'] = 'functional';
            } elseif (in_array('imports', $classification['categories'])) {
                $classification['primary_type'] = 'dependencies';
            } else {
                $classification['primary_type'] = 'minor';
            }
        }

        return $classification;
    }

    /**
     * Generuje doporučení pro regeneraci dokumentace
     */
    private function generateRecommendation(int $semanticScore, array $classification): array
    {
        $recommendation = [
            'should_regenerate' => false,
            'confidence' => 0.0,
            'reasoning' => [],
            'priority' => 'low'
        ];

        // Rozhodování na základě skóre
        if ($semanticScore >= 70) {
            $recommendation['should_regenerate'] = true;
            $recommendation['confidence'] = 0.95;
            $recommendation['priority'] = 'high';
            $recommendation['reasoning'][] = "Vysoké sémantické skóre ({$semanticScore}/100) indikuje významné změny";
        } elseif ($semanticScore >= 40) {
            $recommendation['should_regenerate'] = true;
            $recommendation['confidence'] = 0.75;
            $recommendation['priority'] = 'medium';
            $recommendation['reasoning'][] = "Střední sémantické skóre ({$semanticScore}/100) naznačuje potřebu aktualizace dokumentace";
        } elseif ($semanticScore >= 20) {
            $recommendation['should_regenerate'] = true;
            $recommendation['confidence'] = 0.50;
            $recommendation['priority'] = 'low';
            $recommendation['reasoning'][] = "Nízké sémantické skóre ({$semanticScore}/100), ale změny mohou ovlivnit dokumentaci";
        } else {
            $recommendation['should_regenerate'] = false;
            $recommendation['confidence'] = 0.85;
            $recommendation['priority'] = 'none';
            $recommendation['reasoning'][] = "Velmi nízké sémantické skóre ({$semanticScore}/100) - změny pravděpodobně neovlivní dokumentaci";
        }

        // Úprava na základě klasifikace
        switch ($classification['documentation_relevance']) {
            case 'high':
                $recommendation['should_regenerate'] = true;
                $recommendation['confidence'] = min(0.95, $recommendation['confidence'] + 0.2);
                $recommendation['reasoning'][] = "Změny mají vysokou relevanci pro dokumentaci";
                break;

            case 'none':
                $recommendation['should_regenerate'] = false;
                $recommendation['confidence'] = 0.90;
                $recommendation['priority'] = 'none';
                $recommendation['reasoning'][] = "Změny nemají vliv na dokumentaci (pouze formátování/whitespace)";
                break;
        }

        // Speciální případy
        if ($classification['primary_type'] === 'formatting') {
            $recommendation['should_regenerate'] = false;
            $recommendation['confidence'] = 0.95;
            $recommendation['reasoning'][] = "Pouze formátovací změny - dokumentace zůstává aktuální";
        }

        if (in_array('interfaces', $classification['categories']) ||
            in_array('namespace', $classification['categories'])) {
            $recommendation['should_regenerate'] = true;
            $recommendation['confidence'] = 0.90;
            $recommendation['priority'] = 'high';
            $recommendation['reasoning'][] = "Změny v rozhraních nebo namespace vyžadují aktualizaci dokumentace";
        }

        return $recommendation;
    }
}
</file>

<file path="tests/DigidocsTestCase.php">
<?php

namespace Digihood\Digidocs\Tests;

use Digihood\Digidocs\DigidocsServiceProvider;
use Orchestra\Testbench\TestCase;

abstract class DigidocsTestCase extends TestCase
{
    protected function setUp(): void
    {
        parent::setUp();
    }

    protected function getPackageProviders($app)
    {
        return [
            DigidocsServiceProvider::class,
        ];
    }

    protected function getEnvironmentSetUp($app)
    {
        // Nastavení testovacího prostředí
        $app['config']->set('database.default', 'testing');
        $app['config']->set('database.connections.testing', [
            'driver'   => 'sqlite',
            'database' => ':memory:',
            'prefix'   => '',
        ]);
    }
}
</file>

<file path="tests/Feature/AutoDocsCommandTest.php">
<?php

namespace Digihood\Digidocs\Tests\Feature;

use Digihood\Digidocs\Tests\DigidocsTestCase;
use Digihood\Digidocs\Services\MemoryService;
use Digihood\Digidocs\Agent\DocumentationAgent;
use Illuminate\Support\Facades\File;

class AutoDocsCommandTest extends DigidocsTestCase
{
    protected function setUp(): void
    {
        parent::setUp();
        
        // Vyčisti test adresář
        if (File::exists(base_path('docs/code'))) {
            File::deleteDirectory(base_path('docs/code'));
        }
    }

    /** @test */
    public function it_can_show_stats()
    {
        $this->artisan('autodocs --stats')
            ->expectsOutput('📊 AutoDocs Statistics')
            ->assertExitCode(0);
    }

    /** @test */
    public function it_can_run_cleanup()
    {
        $this->artisan('autodocs --cleanup')
            ->expectsOutput('🧹 Cleaning up memory database...')
            ->assertExitCode(0);
    }

    /** @test */
    public function it_can_run_dry_run()
    {
        // Vytvoř dummy PHP soubor
        $testFile = base_path('app/TestModel.php');
        File::put($testFile, '<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class TestModel extends Model
{
    protected $fillable = [\'name\'];
    
    public function getData(): array
    {
        return [\'test\' => \'data\'];
    }
}');

        $this->artisan('autodocs --dry-run')
            ->expectsOutput('🤖 AutoDocs AI Agent - Starting...')
            ->assertExitCode(0);

        // Vyčisti test soubor
        File::delete($testFile);
    }

    /** @test */
    public function memory_service_works()
    {
        $memory = app(MemoryService::class);
        
        // Test non-existent file
        $status = $memory->needsDocumentation('non-existent-file.php');
        $this->assertArrayHasKey('error', $status);
        $this->assertEquals('File not found', $status['error']);
        
        // Test stats
        $stats = $memory->getStats();
        $this->assertArrayHasKey('total_files', $stats);
        $this->assertArrayHasKey('recent_updates', $stats);
    }

    /** @test */
    public function documentation_agent_can_be_instantiated()
    {
        $agent = app(DocumentationAgent::class);
        $this->assertInstanceOf(DocumentationAgent::class, $agent);
        
        // Test že má správné tools
        $reflection = new \ReflectionClass($agent);
        $method = $reflection->getMethod('tools');
        $method->setAccessible(true);
        $tools = $method->invoke($agent);
        
        $this->assertIsArray($tools);
        $this->assertNotEmpty($tools);
    }

    protected function tearDown(): void
    {
        // Vyčisti test data
        if (File::exists(base_path('docs/code'))) {
            File::deleteDirectory(base_path('docs/code'));
        }
        
        parent::tearDown();
    }
}
</file>

<file path="tests/Feature/ChangeAnalysisAgentTest.php">
<?php

namespace Digihood\Digidocs\Tests\Feature;

use Digihood\Digidocs\Tests\DigidocsTestCase;
use Digihood\Digidocs\Agent\ChangeAnalysisAgent;
use Digihood\Digidocs\Services\DocumentationAnalyzer;
use Digihood\Digidocs\Services\MemoryService;
use Illuminate\Support\Facades\File;

class ChangeAnalysisAgentTest extends DigidocsTestCase
{
    private ChangeAnalysisAgent $agent;
    private DocumentationAnalyzer $analyzer;
    private MemoryService $memory;
    private string $testFilePath;
    private string $testDocPath;

    protected function setUp(): void
    {
        parent::setUp();
        
        $this->agent = new ChangeAnalysisAgent();
        $this->analyzer = new DocumentationAnalyzer();
        $this->memory = new MemoryService();
        
        $this->testFilePath = 'app/Models/TestModel.php';
        $this->testDocPath = base_path('docs/code/Models/TestModel.md');
        
        // Zajisti existenci testovacích adresářů
        File::makeDirectory(dirname(base_path($this->testFilePath)), 0755, true, true);
        File::makeDirectory(dirname($this->testDocPath), 0755, true, true);
    }

    protected function tearDown(): void
    {
        // Vyčisti testovací soubory
        if (File::exists(base_path($this->testFilePath))) {
            File::delete(base_path($this->testFilePath));
        }
        if (File::exists($this->testDocPath)) {
            File::delete($this->testDocPath);
        }
        
        parent::tearDown();
    }

    /** @test */
    public function it_can_analyze_new_file()
    {
        // Vytvoř nový PHP soubor
        $phpContent = '<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class TestModel extends Model
{
    protected $fillable = [\'name\', \'email\'];
    
    public function getName(): string
    {
        return $this->name;
    }
    
    private function internalMethod(): void
    {
        // private logic
    }
}';

        File::put(base_path($this->testFilePath), $phpContent);

        // Test analýzy nového souboru
        $result = $this->agent->generateDocumentationIfNeeded($this->testFilePath);

        $this->assertNotNull($result, 'Nový soubor by měl vygenerovat dokumentaci');
        $this->assertStringContainsString('TestModel', $result);
    }

    /** @test */
    public function it_can_parse_code_structure()
    {
        $phpContent = '<?php

namespace App\Models;

class TestModel
{
    public $publicProperty;
    private $privateProperty;
    
    public function publicMethod(string $param): string
    {
        return $param;
    }
    
    private function privateMethod(): void
    {
        // private logic
    }
}';

        $structure = $this->analyzer->parseCodeStructure($phpContent);

        $this->assertArrayHasKey('classes', $structure);
        $this->assertCount(1, $structure['classes']);
        
        $class = $structure['classes'][0];
        $this->assertEquals('TestModel', $class['name']);
        $this->assertCount(2, $class['methods']);
        $this->assertCount(2, $class['properties']);
    }

    /** @test */
    public function it_detects_public_api_changes()
    {
        $oldContent = '<?php
class TestClass
{
    public function oldMethod(): string
    {
        return "old";
    }
}';

        $newContent = '<?php
class TestClass
{
    public function oldMethod(): string
    {
        return "old";
    }
    
    public function newMethod(): string
    {
        return "new";
    }
}';

        File::put(base_path($this->testFilePath), $newContent);

        // Simuluj existující dokumentaci
        $existingDoc = [
            'path' => $this->testDocPath,
            'content' => '# TestClass Documentation',
            'documented_elements' => [
                ['type' => 'class', 'name' => 'TestClass'],
                ['type' => 'method', 'name' => 'oldMethod']
            ]
        ];

        File::put($this->testDocPath, $existingDoc['content']);

        // Test detekce změn ve veřejném API
        $oldStructure = $this->analyzer->parseCodeStructure($oldContent);
        $newStructure = $this->analyzer->parseCodeStructure($newContent);

        $codeChanges = [
            'old_structure' => $oldStructure,
            'new_structure' => $newStructure,
            'content_changed' => true
        ];

        $relevanceScore = $this->analyzer->calculateDocumentationRelevance($codeChanges, $existingDoc);

        $this->assertGreaterThan(50, $relevanceScore, 'Přidání nové veřejné metody by mělo mít vysoké skóre relevance');
    }

    /** @test */
    public function it_skips_private_only_changes()
    {
        $oldContent = '<?php
class TestClass
{
    public function publicMethod(): string
    {
        return $this->privateMethod();
    }
    
    private function privateMethod(): string
    {
        return "old private";
    }
}';

        $newContent = '<?php
class TestClass
{
    public function publicMethod(): string
    {
        return $this->privateMethod();
    }
    
    private function privateMethod(): string
    {
        return "new private logic";
    }
    
    private function anotherPrivateMethod(): void
    {
        // new private method
    }
}';

        File::put(base_path($this->testFilePath), $newContent);

        // Simuluj existující dokumentaci
        $existingDoc = [
            'path' => $this->testDocPath,
            'content' => '# TestClass Documentation',
            'documented_elements' => [
                ['type' => 'class', 'name' => 'TestClass'],
                ['type' => 'method', 'name' => 'publicMethod']
            ]
        ];

        File::put($this->testDocPath, $existingDoc['content']);

        $oldStructure = $this->analyzer->parseCodeStructure($oldContent);
        $newStructure = $this->analyzer->parseCodeStructure($newContent);

        $codeChanges = [
            'old_structure' => $oldStructure,
            'new_structure' => $newStructure,
            'content_changed' => true
        ];

        $relevanceScore = $this->analyzer->calculateDocumentationRelevance($codeChanges, $existingDoc);

        // Pouze privátní změny by měly mít nižší skóre relevance
        $this->assertLessThan(50, $relevanceScore, 'Pouze privátní změny by měly mít nízké skóre relevance');
    }

    /** @test */
    public function it_handles_missing_documentation()
    {
        $phpContent = '<?php
class TestClass
{
    public function testMethod(): string
    {
        return "test";
    }
}';

        File::put(base_path($this->testFilePath), $phpContent);

        // Test bez existující dokumentace
        $existingDoc = $this->analyzer->analyzeExistingDocumentation($this->testFilePath);
        $this->assertNull($existingDoc, 'Neexistující dokumentace by měla vrátit null');

        $structure = $this->analyzer->parseCodeStructure($phpContent);
        $codeChanges = [
            'old_structure' => [],
            'new_structure' => $structure,
            'content_changed' => true
        ];

        $relevanceScore = $this->analyzer->calculateDocumentationRelevance($codeChanges, null);
        $this->assertEquals(100, $relevanceScore, 'Chybějící dokumentace by měla mít maximální skóre');
    }

    /** @test */
    public function it_records_documented_code_parts()
    {
        $phpContent = '<?php
namespace App\Models;

class TestModel
{
    public $name;
    private $internal;
    
    public function getName(): string
    {
        return $this->name;
    }
    
    private function privateMethod(): void
    {
        // private
    }
}';

        File::put(base_path($this->testFilePath), $phpContent);

        $structure = $this->analyzer->parseCodeStructure($phpContent);
        
        // Simuluj zaznamenání dokumentovaných částí
        $codeParts = [];
        foreach ($structure['classes'] as $class) {
            $codeParts[] = [
                'type' => 'class',
                'name' => $class['name'],
                'signature' => 'class ' . $class['name'],
                'section' => 'Classes'
            ];
            
            foreach ($class['methods'] as $method) {
                if (($method['visibility'] ?? 'public') === 'public') {
                    $codeParts[] = [
                        'type' => 'method',
                        'name' => $class['name'] . '::' . $method['name'],
                        'signature' => 'public function ' . $method['name'] . '()',
                        'section' => 'Methods'
                    ];
                }
            }
        }

        $this->memory->recordDocumentedCodeParts($this->testFilePath, $codeParts);
        $recorded = $this->memory->getDocumentedCodeParts($this->testFilePath);

        $this->assertNotEmpty($recorded, 'Dokumentované části by měly být zaznamenané');
        $this->assertCount(2, $recorded, 'Měly by být zaznamenané 2 části (třída + veřejná metoda)');
    }
}
</file>

<file path="composer.json">
{
    "name": "karlost/digidocs",
    "description": "AI-powered Laravel documentation generator with NeuronAI integration",
    "type": "library",
    "license": "MIT",
    "keywords": ["laravel", "documentation", "ai", "neuronai", "php", "generator"],
    "homepage": "https://github.com/karlost/digidocs",
    "authors": [
        {
            "name": "karlost",
            "email": "karlost@example.com"
        }
    ],
    "require": {
        "php": "^8.2",
        "illuminate/support": "^10.0|^11.0|^12.0",
        "illuminate/database": "^10.0|^11.0|^12.0",
        "illuminate/contracts": "^10.0|^11.0|^12.0",
        "illuminate/console": "^10.0|^11.0|^12.0",
        "inspector-apm/neuron-ai": "^1.0",
        "czproject/git-php": "^4.0",
        "nikic/php-parser": "^5.0"
    },
    "require-dev": {
        "orchestra/testbench": "^8.0|^9.0|^10.0",
        "phpunit/phpunit": "^10.0|^11.0"
    },
    "autoload": {
        "psr-4": {
            "Digihood\\Digidocs\\": "src/"
        }
    },
    "autoload-dev": {
        "psr-4": {
            "Digihood\\Digidocs\\Tests\\": "tests/"
        }
    },
    "extra": {
        "laravel": {
            "providers": [
                "Digihood\\Digidocs\\DigidocsServiceProvider"
            ]
        }
    },
    "minimum-stability": "stable",
    "prefer-stable": true
}
</file>

<file path="src/Commands/WatchCommand.php">
<?php

namespace Digihood\Digidocs\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;
use Digihood\Digidocs\Services\MemoryService;
use Digihood\Digidocs\Agent\DocumentationAgent;
use Digihood\Digidocs\Agent\ChangeAnalysisAgent;
use Digihood\Digidocs\Services\GitWatcherService;
use Exception;

class WatchCommand extends Command
{
    protected $signature = 'digidocs:watch {--interval=5 : Check interval in seconds}
                                          {--path=* : Specific paths to watch}';

    protected $description = 'Watch for Git commits and automatically generate documentation for changed files';

    private bool $shouldStop = false;
    private array $lastCommitHashes = [];

    public function __construct(
        private MemoryService $memory,
        private DocumentationAgent $agent,
        private ChangeAnalysisAgent $changeAnalysisAgent,
        private GitWatcherService $gitWatcher
    ) {
        parent::__construct();
    }

    public function handle(): int
    {
        $this->info('🔍 AutoDocs Git Watcher - Starting...');

        // Zkontroluj jestli je Git dostupný
        if (!$this->gitWatcher->isGitAvailable()) {
            $this->error("❌ Git repository not available. Make sure you're in a Git repository.");
            return 1;
        }

        $interval = (int) $this->option('interval');
        $watchPaths = $this->option('path') ?: config('digidocs.paths.watch', ['app/']);

        $this->line("📋 Watching paths: " . implode(', ', $watchPaths));
        $this->line("⏱️  Check interval: {$interval} seconds");
        $this->line("🔧 Mode: Git commits only");
        $this->line("💡 Press Ctrl+C to stop watching");
        $this->newLine();

        // Inicializace
        $this->initializeWatcher();

        // Registrace signal handleru pro graceful shutdown
        if (function_exists('pcntl_signal')) {
            pcntl_signal(SIGINT, [$this, 'handleSignal']);
            pcntl_signal(SIGTERM, [$this, 'handleSignal']);
        }

        // Hlavní watch loop
        while (!$this->shouldStop) {
            try {
                // Sledování Git commitů
                $changedFiles = $this->checkGitChanges($watchPaths);

                // Zpracování změn
                if (!empty($changedFiles)) {
                    $this->processChanges($changedFiles);
                }

                // Čekání
                sleep($interval);

                // Zpracování signálů (pokud je dostupné)
                if (function_exists('pcntl_signal_dispatch')) {
                    pcntl_signal_dispatch();
                }

            } catch (Exception $e) {
                $this->error("❌ Error during watching: " . $e->getMessage());
                sleep($interval);
            }
        }

        $this->info("🛑 AutoDocs Watcher stopped.");
        return 0;
    }

    /**
     * Inicializuje watcher - uloží aktuální stav
     */
    private function initializeWatcher(): void
    {
        // Inicializace Git hash
        $this->lastCommitHashes = $this->gitWatcher->getCurrentCommitHashes();

        $this->line("✅ Git Watcher initialized");

        // Zobraz aktuální commit info
        $lastCommit = $this->gitWatcher->getLastCommitInfo();
        if ($lastCommit) {
            $this->line("📍 Current commit: " . substr($lastCommit['id'], 0, 8) . " - " . $lastCommit['subject']);
        }
    }

    /**
     * Zkontroluje Git změny a vrátí změněné PHP soubory
     */
    private function checkGitChanges(array $watchPaths): array
    {
        $currentHashes = $this->gitWatcher->getCurrentCommitHashes();
        $changedFiles = [];

        foreach ($currentHashes as $branch => $hash) {
            $lastHash = $this->lastCommitHashes[$branch] ?? null;

            if ($lastHash && $lastHash !== $hash) {
                $this->newLine();
                $this->info("🔄 New commit detected on branch '{$branch}'");

                // Získej commit info
                $commitInfo = $this->gitWatcher->getLastCommitInfo();
                if ($commitInfo) {
                    $this->line("📝 " . substr($commitInfo['id'], 0, 8) . " - " . $commitInfo['subject']);
                    $this->line("👤 " . $commitInfo['author_name'] . " (" . $commitInfo['date'] . ")");
                }

                // Získej změněné soubory z commitu
                $allChangedFiles = $this->gitWatcher->getChangedFilesInCommit($hash, $lastHash);

                // Filtruj pouze PHP soubory v sledovaných cestách
                $filteredFiles = $this->filterChangedFiles($allChangedFiles, $watchPaths);

                $this->line("📁 Total changed files: " . count($allChangedFiles));
                $this->line("🎯 PHP files to document: " . count($filteredFiles));

                if (!empty($filteredFiles)) {
                    foreach ($filteredFiles as $file) {
                        $this->line("   • {$file}");
                    }
                }

                $changedFiles = array_merge($changedFiles, $filteredFiles);
            }
        }

        $this->lastCommitHashes = $currentHashes;
        return $changedFiles;
    }

    /**
     * Filtruje změněné soubory podle sledovaných cest a PHP rozšíření
     */
    private function filterChangedFiles(array $files, array $watchPaths): array
    {
        $extensions = config('digidocs.processing.extensions', ['php']);
        $excludeFiles = config('digidocs.processing.exclude_files', ['*.blade.php']);

        $filtered = [];

        foreach ($files as $file) {
            // Zkontroluj rozšíření
            $extension = strtolower(pathinfo($file, PATHINFO_EXTENSION));
            if (!in_array($extension, $extensions)) {
                continue;
            }

            // Zkontroluj vyloučené soubory
            $fileName = basename($file);
            $shouldExclude = false;
            foreach ($excludeFiles as $pattern) {
                if (fnmatch($pattern, $fileName)) {
                    $shouldExclude = true;
                    break;
                }
            }
            if ($shouldExclude) {
                continue;
            }

            // Zkontroluj jestli je v sledovaných cestách
            $inWatchPath = false;
            foreach ($watchPaths as $watchPath) {
                if (str_starts_with($file, rtrim($watchPath, '/'))) {
                    $inWatchPath = true;
                    break;
                }
            }

            if ($inWatchPath && file_exists(base_path($file))) {
                $filtered[] = $file;
            }
        }

        return $filtered;
    }



    /**
     * Zpracuje detekované změny
     */
    private function processChanges(array $changedFiles): void
    {
        $this->newLine();
        $this->info("🚀 Processing " . count($changedFiles) . " changed files...");

        $processed = 0;
        $errors = 0;

        foreach ($changedFiles as $filePath) {
            try {
                $this->line("📄 Processing: {$filePath}");

                // Použij ChangeAnalysisAgent pro inteligentní rozhodování
                $documentation = $this->changeAnalysisAgent->generateDocumentationIfNeeded($filePath);

                if ($documentation !== null) {
                    // Ulož dokumentaci
                    $docPath = $this->saveDocumentation($filePath, $documentation);

                    // Zaznamenej do memory
                    $currentHash = hash_file('sha256', base_path($filePath));
                    $this->memory->recordDocumentation(
                        $filePath,
                        $currentHash,
                        $docPath
                    );

                    $this->line("   ✅ Generated: {$docPath}");
                    $processed++;
                } else {
                    $this->line("   ⏭️  Skipped (no significant changes)");
                }

            } catch (Exception $e) {
                $this->line("   ❌ Failed: " . $e->getMessage());
                $errors++;
            }
        }

        $this->newLine();
        $this->info("📊 Processed: {$processed}, Errors: {$errors}");
        $this->newLine();
    }

    /**
     * Uloží dokumentaci do souboru
     */
    private function saveDocumentation(string $filePath, string $documentation): string
    {
        $docsPath = config('digidocs.paths.docs');

        // Převeď cestu souboru na cestu dokumentace
        $relativePath = str_replace(['app/', '.php'], ['', '.md'], $filePath);
        $docPath = $docsPath . '/' . $relativePath;

        // Zajisti existenci adresáře
        $directory = dirname($docPath);
        if (!File::exists($directory)) {
            File::makeDirectory($directory, 0755, true);
        }

        // Uloř dokumentaci
        File::put($docPath, $documentation);

        return str_replace(base_path() . '/', '', $docPath);
    }

    /**
     * Signal handler pro graceful shutdown
     */
    public function handleSignal(int $signal): void
    {
        $this->shouldStop = true;
        $this->newLine();
        $this->line("🛑 Received stop signal, shutting down gracefully...");
    }

}
</file>

<file path="src/Services/GitWatcherService.php">
<?php

namespace Digihood\Digidocs\Services;

use CzProject\GitPhp\Git;
use CzProject\GitPhp\GitRepository;
use Exception;

class GitWatcherService
{
    private ?GitRepository $repo = null;

    public function __construct()
    {
        $this->initializeRepository();
    }

    /**
     * Inicializuje Git repository
     */
    private function initializeRepository(): void
    {
        try {
            $git = new Git();
            $this->repo = $git->open(base_path());
        } catch (Exception $e) {
            // Repository není Git repo nebo není dostupné
            $this->repo = null;
        }
    }

    /**
     * Zkontroluje jestli je Git repository dostupné
     */
    public function isGitAvailable(): bool
    {
        return $this->repo !== null;
    }

    /**
     * Získá aktuální commit hash pro všechny branches
     */
    public function getCurrentCommitHashes(): array
    {
        if (!$this->isGitAvailable()) {
            return [];
        }

        try {
            $hashes = [];

            // Získej aktuální branch
            $currentBranch = $this->repo->getCurrentBranchName();
            if ($currentBranch) {
                $commitId = $this->repo->getLastCommitId();
                $hashes[$currentBranch] = $commitId ? (string) $commitId : null;
            }

            return $hashes;
        } catch (Exception $e) {
            return [];
        }
    }

    /**
     * Získá soubory změněné mezi dvěma commity
     */
    public function getChangedFilesInCommit(string $newCommit, string $oldCommit): array
    {
        if (!$this->isGitAvailable()) {
            return [];
        }

        try {
            $output = $this->repo->execute('diff', '--name-only', "{$oldCommit}..{$newCommit}");
            $output = is_array($output) ? implode("\n", $output) : $output;

            $files = array_filter(
                explode("\n", trim($output)),
                fn($file) => !empty(trim($file)) && str_ends_with($file, '.php')
            );

            return array_values($files);
        } catch (Exception $e) {
            return [];
        }
    }

    /**
     * Získá všechny soubory změněné v celé Git historii
     */
    public function getAllChangedFilesInHistory(): array
    {
        if (!$this->isGitAvailable()) {
            return [];
        }

        try {
            // Získej všechny soubory změněné v celé historii (pouze PHP soubory)
            $output = $this->repo->execute('log', '--name-only', '--pretty=format:', '--diff-filter=A');
            $output = is_array($output) ? implode("\n", $output) : $output;

            $files = array_filter(
                explode("\n", trim($output)),
                fn($file) => !empty(trim($file)) && str_ends_with($file, '.php')
            );

            // Odstraň duplicity a vrať unikátní soubory
            return array_values(array_unique($files));
        } catch (Exception $e) {
            return [];
        }
    }

    /**
     * Získá informace o posledním commitu
     */
    public function getLastCommitInfo(): ?array
    {
        if (!$this->isGitAvailable()) {
            return null;
        }

        try {
            $commit = $this->repo->getLastCommit();

            return [
                'id' => (string) $commit->getId(),
                'subject' => $commit->getSubject(),
                'author_name' => $commit->getAuthorName(),
                'author_email' => $commit->getAuthorEmail(),
                'date' => $commit->getDate()->format('Y-m-d H:i:s'),
                'message' => $commit->getBody()
            ];
        } catch (Exception $e) {
            return null;
        }
    }

    /**
     * Získá seznam commitů od určitého commitu
     */
    public function getCommitsSince(string $sinceCommit, int $limit = 10): array
    {
        if (!$this->isGitAvailable()) {
            return [];
        }

        try {
            $output = $this->repo->execute('log', '--oneline', '--no-merges', "-{$limit}", "{$sinceCommit}..HEAD");
            $output = is_array($output) ? implode("\n", $output) : $output;

            return array_filter(
                explode("\n", trim($output)),
                fn($commit) => !empty(trim($commit))
            );
        } catch (Exception $e) {
            return [];
        }
    }

    /**
     * Zkontroluje jestli jsou nějaké uncommitted změny
     */
    public function hasUncommittedChanges(): bool
    {
        if (!$this->isGitAvailable()) {
            return false;
        }

        try {
            return $this->repo->hasChanges();
        } catch (Exception $e) {
            return false;
        }
    }

    /**
     * Získá status repository
     */
    public function getRepositoryStatus(): array
    {
        if (!$this->isGitAvailable()) {
            return [
                'available' => false,
                'error' => 'Git repository not available'
            ];
        }

        try {
            $lastCommit = $this->getLastCommitInfo();
            $currentBranch = $this->repo->getCurrentBranchName();
            $hasChanges = $this->hasUncommittedChanges();

            return [
                'available' => true,
                'current_branch' => $currentBranch,
                'last_commit' => $lastCommit,
                'has_uncommitted_changes' => $hasChanges,
                'repository_path' => $this->repo->getRepositoryPath()
            ];
        } catch (Exception $e) {
            return [
                'available' => false,
                'error' => $e->getMessage()
            ];
        }
    }

    /**
     * Sleduje změny v real-time (pomocí Git hooks by bylo lepší, ale toto je fallback)
     */
    public function watchForChanges(callable $callback, int $interval = 5): void
    {
        if (!$this->isGitAvailable()) {
            throw new Exception('Git repository not available for watching');
        }

        $lastCommitHash = null;
        $currentCommitHashes = $this->getCurrentCommitHashes();

        if (!empty($currentCommitHashes)) {
            $lastCommitHash = array_values($currentCommitHashes)[0];
        }

        while (true) {
            try {
                $currentHashes = $this->getCurrentCommitHashes();

                if (!empty($currentHashes)) {
                    $currentHash = array_values($currentHashes)[0];

                    if ($lastCommitHash && $currentHash !== $lastCommitHash) {
                        // Nový commit detekován
                        $changedFiles = $this->getChangedFilesInCommit($currentHash, $lastCommitHash);

                        $callback([
                            'type' => 'git_commit',
                            'old_commit' => $lastCommitHash,
                            'new_commit' => $currentHash,
                            'changed_files' => $changedFiles,
                            'commit_info' => $this->getLastCommitInfo()
                        ]);

                        $lastCommitHash = $currentHash;
                    }
                }

                sleep($interval);
            } catch (Exception $e) {
                // Log error ale pokračuj ve sledování
                error_log("GitWatcher error: " . $e->getMessage());
                sleep($interval);
            }
        }
    }

    /**
     * Vytvoří Git hook pro automatické spuštění dokumentace
     */
    public function installPostCommitHook(): bool
    {
        if (!$this->isGitAvailable()) {
            return false;
        }

        try {
            $hookPath = $this->repo->getRepositoryPath() . '/.git/hooks/post-commit';

            $hookContent = <<<'BASH'
#!/bin/bash
# AutoDocs post-commit hook
# Automatically generates documentation after each commit

echo "🤖 AutoDocs: Generating documentation for committed changes..."

# Spusť autodocs pro změněné soubory
php artisan autodocs --force

echo "✅ AutoDocs: Documentation generation completed"
BASH;

            file_put_contents($hookPath, $hookContent);
            chmod($hookPath, 0755);

            return true;
        } catch (Exception $e) {
            return false;
        }
    }

    /**
     * Odstraní post-commit hook
     */
    public function uninstallPostCommitHook(): bool
    {
        if (!$this->isGitAvailable()) {
            return false;
        }

        try {
            $hookPath = $this->repo->getRepositoryPath() . '/.git/hooks/post-commit';

            if (file_exists($hookPath)) {
                unlink($hookPath);
            }

            return true;
        } catch (Exception $e) {
            return false;
        }
    }
}
</file>

<file path="config/digidocs.php">
<?php

return [
    /*
    |--------------------------------------------------------------------------
    | Digidocs Configuration
    |--------------------------------------------------------------------------
    |
    | Zde můžete nakonfigurovat základní nastavení pro Digidocs package.
    |
    */

    // Základní nastavení pro package
    'enabled' => true,

    // Prefix pro databázové tabulky
    'table_prefix' => 'digidocs_',

    // Cache nastavení
    'cache' => [
        'enabled' => true,
        'ttl' => 3600, // 1 hodina
    ],

    /*
    |--------------------------------------------------------------------------
    | AI Configuration
    |--------------------------------------------------------------------------
    |
    | Nastavení pro AI dokumentaci generování
    |
    */
    'ai' => [
        'provider' => 'openai',
        'api_key' => env('AUTODOCS_AI_KEY'),
        'model' => env('AUTODOCS_AI_MODEL', 'gpt-4'),
    ],

    /*
    |--------------------------------------------------------------------------
    | Paths Configuration
    |--------------------------------------------------------------------------
    |
    | Cesty pro sledování souborů a ukládání dokumentace
    |
    */
    'paths' => [
        'watch' => ['app/', 'routes/'],
        'docs' => base_path('docs/code'),
        'memory' => storage_path('app/autodocs'),
    ],

    /*
    |--------------------------------------------------------------------------
    | File Processing
    |--------------------------------------------------------------------------
    |
    | Nastavení pro zpracování souborů
    |
    */
    'processing' => [
        'extensions' => ['php'],
        'exclude_dirs' => ['vendor', 'node_modules', 'storage', 'bootstrap/cache'],
        'exclude_files' => ['*.blade.php'],
    ],

    /*
    |--------------------------------------------------------------------------
    | Watch Configuration
    |--------------------------------------------------------------------------
    |
    | Nastavení pro sledování změn a automatické generování dokumentace
    |
    */
    'watch' => [
        'enabled' => env('AUTODOCS_WATCH_ENABLED', true),
        'interval' => env('AUTODOCS_WATCH_INTERVAL', 5), // seconds
        'git_only' => env('AUTODOCS_WATCH_GIT_ONLY', false),
        'files_only' => env('AUTODOCS_WATCH_FILES_ONLY', false),
        'auto_commit_hook' => env('AUTODOCS_AUTO_COMMIT_HOOK', false),
    ],

    /*
    |--------------------------------------------------------------------------
    | Intelligent Analysis Configuration
    |--------------------------------------------------------------------------
    |
    | Nastavení pro inteligentní analýzu změn a rozhodování o regeneraci dokumentace
    |
    */
    'intelligent_analysis' => [
        'enabled' => env('AUTODOCS_INTELLIGENT_ANALYSIS', true),
        'fallback_to_classic' => env('AUTODOCS_FALLBACK_TO_CLASSIC', true),
        'track_documented_parts' => env('AUTODOCS_TRACK_DOCUMENTED_PARTS', true),
        'min_confidence_threshold' => env('AUTODOCS_MIN_CONFIDENCE', 0.7),
        'skip_private_changes' => env('AUTODOCS_SKIP_PRIVATE_CHANGES', true),
        'force_regenerate_on_public_api_changes' => env('AUTODOCS_FORCE_PUBLIC_API', true),
    ],
];
</file>

<file path="src/Agent/DocumentationAgent.php">
<?php

namespace Digihood\Digidocs\Agent;

use NeuronAI\Agent;
use NeuronAI\SystemPrompt;
use NeuronAI\Providers\AIProviderInterface;
use NeuronAI\Providers\OpenAI\OpenAI;
use NeuronAI\Chat\Messages\UserMessage;
use Digihood\Digidocs\Tools\GitAnalyzerTool;
use Digihood\Digidocs\Tools\CodeAnalyzerTool;
use Digihood\Digidocs\Tools\FileHashTool;
use Digihood\Digidocs\Services\CostTracker;
use Digihood\Digidocs\Schema\SimpleDocumentationSchema;

class DocumentationAgent extends Agent
{
    private ?CostTracker $costTracker = null;

    protected function provider(): AIProviderInterface
    {
        return new OpenAI(
            key: config('digidocs.ai.api_key'),
            model: config('digidocs.ai.model', 'gpt-4'),
        );
    }

    /**
     * Nastaví cost tracker pro sledování tokenů
     */
    public function setCostTracker(CostTracker $costTracker): self
    {
        $this->costTracker = $costTracker;
        $this->observe($costTracker);
        return $this;
    }

    public function instructions(): string
    {
        return new SystemPrompt(
            background: [
                "You are an AI Agent specialized in generating high-quality PHP code documentation.",
                "You analyze Laravel PHP files and create comprehensive Markdown documentation.",
                "You understand Laravel conventions, design patterns, and best practices.",
                "You have access to tools for Git analysis, code parsing, and file tracking.",
                "Your goal is to create developer-friendly documentation that is clear, accurate, and useful."
            ],
            steps: [
                "Use the available tools to gather comprehensive information about the PHP file",
                "Analyze the code structure, including classes, methods, properties, and their relationships",
                "Extract and understand existing docblocks and comments",
                "Identify the file's purpose within the Laravel application context",
                "Consider Git history and recent changes for context",
                "Generate structured Markdown documentation that follows consistent formatting"
            ],
            output: [
                "Generate structured documentation data that will be converted to Markdown",
                "Create a comprehensive title that describes the file's main purpose",
                "Provide a clear overview explaining what the file does and its role in the application",
                "Organize content into logical sections (Overview, Classes, Methods, Usage Examples, etc.)",
                "Document all public classes, methods, and properties with detailed descriptions",
                "Include parameter descriptions, return types, and usage examples for methods",
                "Add Laravel-specific context (Controller actions, Model relationships, middleware, etc.)",
                "Use professional Czech language for descriptions, but keep code examples in English",
                "Focus on public APIs and interfaces that other developers will use",
                "Include practical code examples for complex methods or Laravel-specific functionality",
                "Provide information about dependencies and relationships with other parts of the application",
                "Always use the available tools to gather accurate information before generating documentation",
                "Be comprehensive but concise - include all important information without unnecessary verbosity",
                "Structure the output to match the DocumentationSchema format for consistent results"
            ]
        );
    }

    protected function tools(): array
    {
        return [
            GitAnalyzerTool::make(),
            CodeAnalyzerTool::make(),
            FileHashTool::make(),
        ];
    }

    /**
     * Vygeneruje dokumentaci pro konkrétní soubor
     */
    public function generateDocumentationForFile(string $filePath): string
    {
        // Nastaví aktuální soubor pro cost tracking
        if ($this->costTracker) {
            $this->costTracker->setCurrentFile($filePath);
        }

        $prompt = $this->buildPromptForFile($filePath);

        // Použij regular chat s vylepšeným promptem
        $response = $this->chat(new UserMessage($prompt));
        $content = $response->getContent();

        // Validuj a oprav formát výstupu
        $content = $this->validateAndFixMarkdownOutput($content);

        // Resetuj aktuální soubor
        if ($this->costTracker) {
            $this->costTracker->setCurrentFile(null);
        }

        return $content;
    }

    /**
     * Vytvoří prompt pro analýzu konkrétního souboru
     */
    private function buildPromptForFile(string $filePath): string
    {
        return "Prosím analyzuj PHP soubor: {$filePath} a vygeneruj kompletní Markdown dokumentaci.

KRITICKÉ: Výstup musí být validní Markdown formát, ne JSON! Začni přímo nadpisem # a pokračuj strukturovanými sekcemi.

Postupuj takto:
1. Použij dostupné nástroje pro analýzu souboru, Git historie a kódové struktury
2. Pochop účel a funkci souboru v kontextu Laravel aplikace
3. Vygeneruj kompletní Markdown dokumentaci v tomto formátu:

# [Název souboru/komponenty]

[Stručný ale kompletní popis účelu a role souboru v aplikaci]

## Přehled tříd a zodpovědností

[Detailní popis všech tříd v souboru a jejich zodpovědností]

## Veřejné metody

[Pro každou veřejnou metodu zahrň:
- Název metody a její účel
- Parametry (typy, názvy, popisy)
- Návratové hodnoty
- Příklady volání s kódem]

## Vlastnosti a konstanty

[Popis veřejných vlastností a konstant]

## Laravel funkcionality

[Laravel-specifické funkcionality jako relationships, scopes, middleware, events, atd.]

## Příklady použití

[Praktické příklady použití s kódem v PHP]

## Závislosti a vztahy

[Závislosti a vztahy s dalšími částmi aplikace]

POŽADAVKY:
- Výstup musí být validní Markdown s nadpisy #, ##, ###
- Použij češtinu pro popisy, angličtinu pro kód
- Zaměř se na veřejné API pro vývojáře
- Každá sekce musí obsahovat užitečné informace
- Zahrň code bloky s ```php pro příklady";
    }

    /**
     * Vygeneruje souhrnnou dokumentaci pro více souborů
     */
    public function generateSummaryDocumentation(array $filePaths): string
    {
        $filesList = implode("\n- ", $filePaths);

        $prompt = "Prosím vygeneruj souhrnnou dokumentaci pro následující PHP soubory:
- {$filesList}

Použij dostupné nástroje pro analýzu všech souborů a vytvoř přehlednou dokumentaci, která:
1. Popíše účel a vztahy mezi soubory
2. Zdůrazní klíčové komponenty a jejich funkcionalitu
3. Poskytne přehled architektury a design patterns
4. Bude strukturovaná a snadno čitelná

Dokumentace by měla sloužit jako úvod do této části kódové základny.";

        $response = $this->chat(
            new \NeuronAI\Chat\Messages\UserMessage($prompt)
        );

        return $response->getContent();
    }

    /**
     * Validuje a opravuje formát výstupu - zajistí, že je to Markdown, ne JSON
     */
    private function validateAndFixMarkdownOutput(string $content): string
    {
        $trimmedContent = trim($content);

        // Zkontroluj, zda výstup začína JSON objektem nebo polem
        if (str_starts_with($trimmedContent, '{') || str_starts_with($trimmedContent, '[')) {
            \Log::warning("DocumentationAgent: Detected JSON output instead of Markdown, attempting to fix");

            try {
                $jsonData = json_decode($trimmedContent, true);

                if (json_last_error() === JSON_ERROR_NONE) {
                    // Pokud je to validní JSON, pokus se převést na Markdown
                    return $this->convertJsonToMarkdown($jsonData);
                }
            } catch (\Exception $e) {
                \Log::error("DocumentationAgent: Failed to parse JSON: " . $e->getMessage());
            }
        }

        // Zkontroluj, zda výstup obsahuje základní Markdown strukturu
        if (!str_contains($content, '#') && !str_contains($content, '##')) {
            \Log::warning("DocumentationAgent: Output doesn't contain Markdown headers, might be malformed");
        }

        return $content;
    }

    /**
     * Převede JSON strukturu na Markdown
     */
    private function convertJsonToMarkdown(array $data): string
    {
        $markdown = '';

        // Název dokumentu
        if (isset($data['name'])) {
            $markdown .= "# " . $data['name'] . "\n\n";
        }

        // Popis
        if (isset($data['description'])) {
            $markdown .= $data['description'] . "\n\n";
        }

        // Sekce
        if (isset($data['sections']) && is_array($data['sections'])) {
            foreach ($data['sections'] as $section) {
                if (isset($section['title'])) {
                    $markdown .= "## " . $section['title'] . "\n\n";
                }

                if (isset($section['content'])) {
                    $markdown .= $section['content'] . "\n\n";
                }

                // Metody
                if (isset($section['methods']) && is_array($section['methods'])) {
                    foreach ($section['methods'] as $method) {
                        if (isset($method['název'])) {
                            $markdown .= "### " . $method['název'] . "()\n\n";
                        }
                        if (isset($method['popis'])) {
                            $markdown .= $method['popis'] . "\n\n";
                        }
                        if (isset($method['parametry'])) {
                            $markdown .= "**Parametry:** " . $method['parametry'] . "\n\n";
                        }
                        if (isset($method['návratová_hodnota'])) {
                            $markdown .= "**Návratová hodnota:** " . $method['návratová_hodnota'] . "\n\n";
                        }
                    }
                }
            }
        }

        // Poznámka
        if (isset($data['poznámka'])) {
            $markdown .= "## Poznámka\n\n" . $data['poznámka'] . "\n\n";
        }

        return $markdown;
    }
}
</file>

<file path="src/Agent/ChangeAnalysisAgent.php">
<?php

namespace Digihood\Digidocs\Agent;

use NeuronAI\Agent;
use NeuronAI\SystemPrompt;
use NeuronAI\Providers\AIProviderInterface;
use NeuronAI\Providers\OpenAI\OpenAI;
use Digihood\Digidocs\Tools\CodeDiffTool;
use Digihood\Digidocs\Tools\AstCompareTool;
use Digihood\Digidocs\Tools\SemanticAnalysisTool;
use Digihood\Digidocs\Services\DocumentationAnalyzer;
use Digihood\Digidocs\Services\CostTracker;
use Exception;

class ChangeAnalysisAgent extends Agent
{
    private ?DocumentationAnalyzer $documentationAnalyzer = null;
    private ?CostTracker $costTracker = null;

    private function getDocumentationAnalyzer(): DocumentationAnalyzer
    {
        if ($this->documentationAnalyzer === null) {
            $this->documentationAnalyzer = new DocumentationAnalyzer();
        }
        return $this->documentationAnalyzer;
    }

    /**
     * Nastaví cost tracker pro sledování tokenů
     */
    public function setCostTracker(CostTracker $costTracker): self
    {
        $this->costTracker = $costTracker;
        $this->observe($costTracker);
        return $this;
    }

    protected function provider(): AIProviderInterface
    {
        return new OpenAI(
            key: config('digidocs.ai.api_key'),
            model: config('digidocs.ai.model', 'gpt-4'),
        );
    }

    public function instructions(): string
    {
        return new SystemPrompt(
            background: [
                "You are an expert in analyzing PHP code changes and deciding whether documentation needs to be updated.",
                "You analyze changes in PHP files and decide whether documentation regeneration is needed.",
                "Your goal is to minimize unnecessary documentation regenerations while keeping documentation current.",
                "You focus on structural and semantic changes that affect API or functionality."
            ],
            steps: [
                "Use all available tools for comprehensive change analysis",
                "Distinguish between cosmetic changes (whitespace, comments) and significant changes",
                "Structural changes (new classes, methods, properties) require documentation updates",
                "Semantic changes (logic changes, parameters) also require updates",
                "Changes only in comments or formatting usually don't require updates",
                "Provide clear reasoning for your decision with specific evidence",
                "Include confidence score for your decision",
                "If uncertain, recommend documentation update for safety"
            ],
            output: [
                "Provide structured analysis in JSON format",
                "Include should_regenerate boolean decision",
                "Include confidence score (0.0-1.0)",
                "Include reason for the decision",
                "Include detailed reasoning array with specific evidence",
                "Include semantic score (0-100) indicating change significance"
            ]
        );
    }

    protected function tools(): array
    {
        return [
            CodeDiffTool::make(),
            AstCompareTool::make(),
            SemanticAnalysisTool::make(),
        ];
    }

    /**
     * Hlavní metoda - generuje dokumentaci pouze pokud je potřeba
     */
    public function generateDocumentationIfNeeded(string $filePath): ?string
    {
        try {
            \Log::info("ChangeAnalysisAgent: Processing {$filePath}");

            // Zkontroluj jestli je inteligentní analýza zapnutá
            if (!config('digidocs.intelligent_analysis.enabled', true)) {
                \Log::info("Intelligent analysis disabled, using classic DocumentationAgent");
                return $this->generateWithClassicAgent($filePath);
            }

            // Získej obsah souborů
            $oldContent = $this->getOldFileContent($filePath);
            $newContent = $this->getCurrentFileContent($filePath);

            if ($newContent === null) {
                \Log::warning("Could not read file content for {$filePath}");
                return null;
            }

            // NOVÉ: Získej existující dokumentaci
            $existingDoc = $this->getDocumentationAnalyzer()->analyzeExistingDocumentation($filePath);

            // NOVÉ: Analyzuj strukturu kódu
            $oldStructure = $oldContent ? $this->getDocumentationAnalyzer()->parseCodeStructure($oldContent) : [];
            $newStructure = $this->getDocumentationAnalyzer()->parseCodeStructure($newContent);

            // Proveď rozšířenou analýzu změn - POUZE heuristická analýza, žádné AI
            $analysis = $this->analyzeChangesWithDocumentation($filePath, $oldContent, $newContent, $oldStructure, $newStructure, $existingDoc);

            // Zaznamenej analýzu do databáze
            $this->recordAnalysis($filePath, $analysis);

            // Rozhodni na základě analýzy
            if (!$analysis['should_regenerate']) {
                \Log::info("Skipping documentation for {$filePath}: {$analysis['reason']}");
                return null;
            }

            \Log::info("Generating documentation for {$filePath}: {$analysis['reason']}");
            return $this->generateWithClassicAgent($filePath);

        } catch (Exception $e) {
            \Log::error("ChangeAnalysisAgent error for {$filePath}: " . $e->getMessage());

            // Fallback na klasický agent při chybě
            if (config('digidocs.intelligent_analysis.fallback_to_classic', true)) {
                \Log::info("Falling back to classic DocumentationAgent");
                return $this->generateWithClassicAgent($filePath);
            }

            return null;
        }
    }

    /**
     * Rozhodne, zda je potřeba regenerovat dokumentaci pro soubor
     * (zachováno pro zpětnou kompatibilitu)
     */
    public function shouldRegenerateDocumentation(
        string $filePath,
        string $oldContent,
        string $newContent
    ): array {
        try {
            \Log::info("ChangeAnalysisAgent: Analyzing {$filePath}");
            \Log::info("Old content length: " . strlen($oldContent));
            \Log::info("New content length: " . strlen($newContent));

            // Rychlá kontrola - pokud je obsah stejný
            if ($oldContent === $newContent) {
                \Log::info("ChangeAnalysisAgent: Content identical, skipping regeneration");
                return [
                    'should_regenerate' => false,
                    'confidence' => 1.0,
                    'reason' => 'identical_content',
                    'reasoning' => ['Obsah souboru je identický'],
                    'change_summary' => [],
                    'semantic_score' => 0
                ];
            }

            // Pokud je starý obsah prázdný, je to nový soubor
            if (empty(trim($oldContent))) {
                \Log::info("ChangeAnalysisAgent: New file detected, regenerating");
                return [
                    'should_regenerate' => true,
                    'confidence' => 1.0,
                    'reason' => 'new_file',
                    'reasoning' => ['Nový soubor vyžaduje dokumentaci'],
                    'change_summary' => [],
                    'semantic_score' => 100
                ];
            }

            $prompt = $this->buildAnalysisPrompt($filePath, $oldContent, $newContent);

            \Log::info("ChangeAnalysisAgent: Sending prompt to AI using run() method");
            $response = $this->run(
                new \NeuronAI\Chat\Messages\UserMessage($prompt)
            );

            \Log::info("ChangeAnalysisAgent: Received AI response");
            $result = $this->parseResponse($response->getContent());

            \Log::info("ChangeAnalysisAgent: Parsed result", $result);

            return [
                'should_regenerate' => $result['should_regenerate'] ?? true, // default true pro bezpečnost
                'confidence' => $result['confidence'] ?? 0.5,
                'reason' => $result['reason'] ?? 'unknown',
                'reasoning' => $result['reasoning'] ?? [],
                'change_summary' => $result['change_summary'] ?? [],
                'semantic_score' => $result['semantic_score'] ?? 50,
                'agent_response' => $response->getContent()
            ];

        } catch (Exception $e) {
            \Log::error("ChangeAnalysisAgent error: " . $e->getMessage());
            // V případě chyby raději regeneruj dokumentaci
            return [
                'should_regenerate' => true,
                'confidence' => 0.0,
                'reason' => 'analysis_error',
                'reasoning' => ['Chyba při analýze změn: ' . $e->getMessage()],
                'change_summary' => [],
                'semantic_score' => 100,
                'error' => $e->getMessage()
            ];
        }
    }

    /**
     * Manuálně spustí Tools a vrátí jejich výsledky
     */
    private function runToolsManually(string $filePath, string $oldContent, string $newContent): array
    {
        $results = [];

        try {
            // 1. CodeDiffTool
            $codeDiffTool = new \Digihood\Digidocs\Tools\CodeDiffAnalyzer();
            $results['diff'] = $codeDiffTool($filePath, null, null, $oldContent, $newContent);
        } catch (\Exception $e) {
            $results['diff'] = ['status' => 'error', 'error' => $e->getMessage()];
        }

        try {
            // 2. AstCompareTool
            $astCompareTool = new \Digihood\Digidocs\Tools\AstComparer();
            $results['ast'] = $astCompareTool($oldContent, $newContent, $filePath);
        } catch (\Exception $e) {
            $results['ast'] = ['status' => 'error', 'error' => $e->getMessage()];
        }

        try {
            // 3. SemanticAnalysisTool
            $semanticTool = new \Digihood\Digidocs\Tools\SemanticAnalyzer();
            $results['semantic'] = $semanticTool(
                json_encode($results['diff']),
                json_encode($results['ast']),
                $filePath
            );
        } catch (\Exception $e) {
            $results['semantic'] = ['status' => 'error', 'error' => $e->getMessage()];
        }

        return $results;
    }

    /**
     * Vytvoří prompt pro analýzu změn
     */
    private function buildAnalysisPrompt(string $filePath, string $oldContent, string $newContent): string
    {
        return "Analyzuj změny v PHP souboru a rozhodni, zda je potřeba regenerovat dokumentaci.

**Soubor:** {$filePath}

**Úkol:**
Porovnej starý a nový obsah souboru a rozhodni, jestli je potřeba regenerovat dokumentaci.
Máš k dispozici nástroje pro analýzu kódu - použij je podle potřeby.

**Starý obsah:**
```php
{$oldContent}
```

**Nový obsah:**
```php
{$newContent}
```

**Očekávaný výstup:**
Poskytni strukturovanou analýzu ve formátu:

```json
{
    \"should_regenerate\": true/false,
    \"confidence\": 0.0-1.0,
    \"reason\": \"structural_changes|semantic_changes|cosmetic_only|formatting_only\",
    \"reasoning\": [
        \"Konkrétní důvod 1\",
        \"Konkrétní důvod 2\"
    ],
    \"change_summary\": {
        \"total_changes\": number,
        \"change_types\": [\"array of change types\"],
        \"severity\": \"major|minor|minimal|none\"
    },
    \"semantic_score\": 0-100
}
```

**Kritéria pro rozhodování:**
- Strukturální změny (nové/změněné třídy, metody, vlastnosti) → regeneruj
- Sémantické změny (změny logiky, parametrů, návratových hodnot) → regeneruj
- Změny v komentářích nebo docblocks → možná regeneruj
- Pouze whitespace/formátování → neregeneruj
- Změny v importech → zvažuj podle kontextu
- Pokud si nejsi jistý → raději regeneruj

Buď konkrétní a uveď jasné důvody pro své rozhodnutí.";
    }

    /**
     * Parsuje odpověď agenta a extrahuje strukturovaná data
     */
    private function parseResponse(string $response): array
    {
        // Pokus o extrakci JSON z odpovědi
        if (preg_match('/```json\s*(\{.*?\})\s*```/s', $response, $matches)) {
            $jsonData = json_decode($matches[1], true);
            if ($jsonData !== null) {
                return $jsonData;
            }
        }

        // Pokus o nalezení JSON bez markdown
        if (preg_match('/\{.*\}/s', $response, $matches)) {
            $jsonData = json_decode($matches[0], true);
            if ($jsonData !== null) {
                return $jsonData;
            }
        }

        // Fallback parsing - hledej klíčová slova
        $result = [
            'should_regenerate' => true, // default true pro bezpečnost
            'confidence' => 0.5,
            'reason' => 'unknown',
            'reasoning' => [],
            'change_summary' => [],
            'semantic_score' => 50
        ];

        // Hledej should_regenerate
        if (preg_match('/should_regenerate["\']?\s*:\s*(true|false)/i', $response, $matches)) {
            $result['should_regenerate'] = strtolower($matches[1]) === 'true';
        } elseif (preg_match('/(neregeneruj|nepotřebuje|není potřeba|no need)/i', $response)) {
            $result['should_regenerate'] = false;
        } elseif (preg_match('/(regeneruj|potřebuje|je potřeba|need|update)/i', $response)) {
            $result['should_regenerate'] = true;
        }

        // Hledej confidence
        if (preg_match('/confidence["\']?\s*:\s*([0-9.]+)/i', $response, $matches)) {
            $result['confidence'] = (float) $matches[1];
        }

        // Hledej semantic_score
        if (preg_match('/semantic_score["\']?\s*:\s*([0-9]+)/i', $response, $matches)) {
            $result['semantic_score'] = (int) $matches[1];
        }

        // Hledej reason
        if (preg_match('/reason["\']?\s*:\s*["\']([^"\']+)["\']?/i', $response, $matches)) {
            $result['reason'] = $matches[1];
        }

        // Extrahuj reasoning jako seznam řádků obsahujících důvody
        $lines = explode("\n", $response);
        $reasoning = [];
        foreach ($lines as $line) {
            $line = trim($line);
            if (preg_match('/^[-*•]\s*(.+)/', $line, $matches)) {
                $reasoning[] = $matches[1];
            } elseif (preg_match('/^\d+\.\s*(.+)/', $line, $matches)) {
                $reasoning[] = $matches[1];
            }
        }

        if (!empty($reasoning)) {
            $result['reasoning'] = $reasoning;
        } else {
            $result['reasoning'] = ['Automaticky parsovaná odpověď z AI agenta'];
        }

        return $result;
    }

    /**
     * Generuje dokumentaci pomocí klasického DocumentationAgent
     */
    private function generateWithClassicAgent(string $filePath): string
    {
        // KLÍČOVÁ OPRAVA: Vytvoř novou instanci agenta místo mazání historie
        // Tím se zachovají systémové instrukce a vyřeší se problém s JSON výstupem
        $documentationAgent = new \Digihood\Digidocs\Agent\DocumentationAgent();

        // Nastav cost tracker pokud je dostupný
        if ($this->costTracker) {
            $documentationAgent->setCostTracker($this->costTracker);
        }

        return $documentationAgent->generateDocumentationForFile($filePath);
    }

    /**
     * Získá obsah aktuálního souboru
     */
    private function getCurrentFileContent(string $filePath): ?string
    {
        $fullPath = base_path($filePath);

        if (!file_exists($fullPath)) {
            return null;
        }

        return file_get_contents($fullPath);
    }

    /**
     * Získá obsah starého souboru z Git
     */
    private function getOldFileContent(string $filePath): string
    {
        try {
            $gitWatcher = app(\Digihood\Digidocs\Services\GitWatcherService::class);

            // Zkus získat obsah z předchozího commitu
            $currentCommitHashes = $gitWatcher->getCurrentCommitHashes();
            if (!empty($currentCommitHashes)) {
                $currentCommit = array_values($currentCommitHashes)[0];

                // Použij exec() místo shell_exec() pro lepší error handling
                // Přesměruj stderr podle OS
                $nullDevice = PHP_OS_FAMILY === 'Windows' ? 'NUL' : '/dev/null';
                $command = "git show {$currentCommit}~1:\"{$filePath}\" 2>{$nullDevice}";
                $output = [];
                $returnCode = 0;

                exec($command, $output, $returnCode);

                // Pokud příkaz uspěl a má výstup
                if ($returnCode === 0 && !empty($output)) {
                    return implode("\n", $output);
                }

                // Pokud soubor neexistoval v předchozím commitu, je to OK (nový soubor)
                if ($returnCode !== 0) {
                    \Log::info("File {$filePath} did not exist in previous commit (new file)");
                }
            }
        } catch (\Exception $e) {
            \Log::info("Git content retrieval failed for {$filePath}: " . $e->getMessage());
        }

        // Fallback - prázdný obsah (nový soubor)
        return '';
    }

    /**
     * Rozšířená analýza změn s kontextem dokumentace
     */
    private function analyzeChangesWithDocumentation(
        string $filePath,
        string $oldContent,
        string $newContent,
        array $oldStructure,
        array $newStructure,
        ?array $existingDoc
    ): array {
        // Rychlé kontroly
        if ($oldContent === $newContent) {
            return [
                'should_regenerate' => false,
                'confidence' => 1.0,
                'reason' => 'identical_content',
                'reasoning' => ['Obsah souboru je identický'],
                'change_summary' => [],
                'semantic_score' => 0,
                'existing_doc_path' => $existingDoc['path'] ?? null,
                'doc_relevance_score' => 0,
                'affected_doc_sections' => []
            ];
        }

        if (empty(trim($oldContent))) {
            return [
                'should_regenerate' => true,
                'confidence' => 1.0,
                'reason' => 'new_file',
                'reasoning' => ['Nový soubor vyžaduje dokumentaci'],
                'change_summary' => [],
                'semantic_score' => 100,
                'existing_doc_path' => null,
                'doc_relevance_score' => 100,
                'affected_doc_sections' => []
            ];
        }

        // Vypočítej dopad na dokumentaci
        $codeChanges = [
            'old_structure' => $oldStructure,
            'new_structure' => $newStructure,
            'content_changed' => true
        ];

        $docRelevanceScore = $this->getDocumentationAnalyzer()->calculateDocumentationRelevance($codeChanges, $existingDoc);

        // Použij vylepšené heuristiky
        $heuristicResult = $this->advancedHeuristicAnalysis($filePath, $oldContent, $newContent, $oldStructure, $newStructure, $existingDoc);

        // DEBUG: Log heuristiky
        \Log::info("ChangeAnalysisAgent heuristic result for {$filePath}", [
            'should_regenerate' => $heuristicResult['should_regenerate'],
            'reason' => $heuristicResult['reason'],
            'confidence' => $heuristicResult['confidence'] ?? 0.8,
            'doc_relevance_score' => $docRelevanceScore,
            'existing_doc' => $existingDoc ? 'exists' : 'missing'
        ]);

        return [
            'should_regenerate' => $heuristicResult['should_regenerate'],
            'confidence' => $heuristicResult['confidence'] ?? 0.8,
            'reason' => $heuristicResult['reason'],
            'reasoning' => $heuristicResult['reasoning'] ?? [],
            'change_summary' => $heuristicResult['change_summary'] ?? [],
            'semantic_score' => $docRelevanceScore,
            'existing_doc_path' => $existingDoc['path'] ?? null,
            'doc_relevance_score' => $docRelevanceScore,
            'affected_doc_sections' => $heuristicResult['affected_sections'] ?? []
        ];
    }

    /**
     * Analyzuje změny v souboru (původní metoda pro zpětnou kompatibilitu)
     */
    private function analyzeChanges(string $filePath, string $oldContent, string $newContent): array
    {
        // Rychlé kontroly
        if ($oldContent === $newContent) {
            return [
                'should_regenerate' => false,
                'confidence' => 1.0,
                'reason' => 'identical_content',
                'reasoning' => ['Obsah souboru je identický'],
                'change_summary' => [],
                'semantic_score' => 0
            ];
        }

        if (empty(trim($oldContent))) {
            return [
                'should_regenerate' => true,
                'confidence' => 1.0,
                'reason' => 'new_file',
                'reasoning' => ['Nový soubor vyžaduje dokumentaci'],
                'change_summary' => [],
                'semantic_score' => 100
            ];
        }

        // Použij jednoduché heuristiky místo AI analýzy (rychlejší a spolehlivější)
        return $this->simpleHeuristicAnalysis($filePath, $oldContent, $newContent);
    }

    /**
     * Jednoduchá heuristická analýza bez AI
     */
    private function simpleHeuristicAnalysis(string $filePath, string $oldContent, string $newContent): array
    {
        $oldLines = explode("\n", $oldContent);
        $newLines = explode("\n", $newContent);

        $totalChanges = abs(count($newLines) - count($oldLines));

        // Lepší kontrola whitespace změn - normalizuj všechny whitespace
        $oldNormalized = $this->normalizeWhitespace($oldContent);
        $newNormalized = $this->normalizeWhitespace($newContent);

        if ($oldNormalized === $newNormalized) {
            \Log::info("ChangeAnalysisAgent: Whitespace only changes detected for {$filePath}");
            return [
                'should_regenerate' => false,
                'confidence' => 0.95,
                'reason' => 'whitespace_only',
                'reasoning' => ['Pouze změny v whitespace - dokumentace zůstává aktuální'],
                'change_summary' => ['total_changes' => $totalChanges, 'severity' => 'minimal'],
                'semantic_score' => 5
            ];
        }

        // Lepší kontrola komentářů - odstraň všechny typy komentářů
        $oldCodeOnly = $this->removeComments($oldContent);
        $newCodeOnly = $this->removeComments($newContent);

        // Normalizuj whitespace po odstranění komentářů
        $oldCodeNormalized = $this->normalizeWhitespace($oldCodeOnly);
        $newCodeNormalized = $this->normalizeWhitespace($newCodeOnly);

        if ($oldCodeNormalized === $newCodeNormalized) {
            \Log::info("ChangeAnalysisAgent: Comments only changes detected for {$filePath}");
            return [
                'should_regenerate' => false,
                'confidence' => 0.85,
                'reason' => 'comments_only',
                'reasoning' => ['Pouze změny v komentářích - dokumentace zůstává aktuální'],
                'change_summary' => ['total_changes' => $totalChanges, 'severity' => 'minor'],
                'semantic_score' => 15
            ];
        }

        // Kontrola strukturálních změn (třídy, metody, vlastnosti)
        $hasStructuralChanges = $this->detectStructuralChanges($oldContent, $newContent);

        if ($hasStructuralChanges) {
            \Log::info("ChangeAnalysisAgent: Structural changes detected for {$filePath}");
            return [
                'should_regenerate' => true,
                'confidence' => 0.9,
                'reason' => 'structural_changes',
                'reasoning' => ['Detekované strukturální změny (třídy, metody, vlastnosti)'],
                'change_summary' => ['total_changes' => $totalChanges, 'severity' => 'major'],
                'semantic_score' => 85
            ];
        }

        // Malé změny v kódu
        if ($totalChanges <= 3) {
            \Log::info("ChangeAnalysisAgent: Minor code changes detected for {$filePath}");
            return [
                'should_regenerate' => true,
                'confidence' => 0.6,
                'reason' => 'minor_code_changes',
                'reasoning' => ['Malé změny v kódu - pravděpodobně potřebná aktualizace dokumentace'],
                'change_summary' => ['total_changes' => $totalChanges, 'severity' => 'minor'],
                'semantic_score' => 40
            ];
        }

        // Větší změny v kódu
        \Log::info("ChangeAnalysisAgent: Major code changes detected for {$filePath}");
        return [
            'should_regenerate' => true,
            'confidence' => 0.8,
            'reason' => 'major_code_changes',
            'reasoning' => ['Významné změny v kódu - nutná aktualizace dokumentace'],
            'change_summary' => ['total_changes' => $totalChanges, 'severity' => 'major'],
            'semantic_score' => 75
        ];
    }

    /**
     * Detekuje strukturální změny v PHP kódu
     */
    private function detectStructuralChanges(string $oldContent, string $newContent): bool
    {
        // Jednoduché regex patterns pro PHP struktury
        $patterns = [
            '/class\s+\w+/',
            '/interface\s+\w+/',
            '/trait\s+\w+/',
            '/function\s+\w+\s*\(/',
            '/public\s+function\s+\w+/',
            '/private\s+function\s+\w+/',
            '/protected\s+function\s+\w+/',
            '/public\s+\$\w+/',
            '/private\s+\$\w+/',
            '/protected\s+\$\w+/',
            '/const\s+\w+\s*=/',
        ];

        foreach ($patterns as $pattern) {
            $oldMatches = preg_match_all($pattern, $oldContent);
            $newMatches = preg_match_all($pattern, $newContent);

            if ($oldMatches !== $newMatches) {
                return true;
            }
        }

        return false;
    }

    /**
     * Zaznamenej analýzu do databáze
     */
    private function recordAnalysis(string $filePath, array $analysis): void
    {
        try {
            $memoryService = app(\Digihood\Digidocs\Services\MemoryService::class);
            $currentHash = hash_file('sha256', base_path($filePath));

            // Použij metodu z MemoryService (pokud existuje)
            if (method_exists($memoryService, 'recordAnalysis')) {
                $memoryService->recordAnalysis($filePath, $currentHash, $analysis);
            }
        } catch (\Exception $e) {
            \Log::warning("Failed to record analysis for {$filePath}: " . $e->getMessage());
        }
    }

    /**
     * Rychlá analýza bez AI - pouze na základě hash porovnání
     */
    public function quickAnalysis(string $filePath, string $oldHash, string $newHash): array
    {
        if ($oldHash === $newHash) {
            return [
                'should_regenerate' => false,
                'confidence' => 1.0,
                'reason' => 'no_changes',
                'reasoning' => ['Soubor se nezměnil (stejný hash)'],
                'change_summary' => ['total_changes' => 0, 'severity' => 'none'],
                'semantic_score' => 0
            ];
        }

        // Pro rychlou analýzu - pokud se hash změnil, doporuč regeneraci
        return [
            'should_regenerate' => true,
            'confidence' => 0.7,
            'reason' => 'hash_changed',
            'reasoning' => ['Hash souboru se změnil - potřebná detailní analýza'],
            'change_summary' => ['total_changes' => 1, 'severity' => 'unknown'],
            'semantic_score' => 50
        ];
    }

    /**
     * Vylepšené heuristiky s kontextem dokumentace
     */
    private function advancedHeuristicAnalysis(
        string $filePath,
        string $oldContent,
        string $newContent,
        array $oldStructure,
        array $newStructure,
        ?array $existingDoc
    ): array {
        // 1. Žádná dokumentace = vždy generuj
        if (!$existingDoc) {
            return [
                'should_regenerate' => true,
                'confidence' => 1.0,
                'reason' => 'no_existing_doc',
                'reasoning' => ['Žádná existující dokumentace - nutné vygenerovat'],
                'change_summary' => ['severity' => 'major'],
                'affected_sections' => []
            ];
        }

        // 2. Pouze privátní změny = zvažuj podle rozsahu změn
        if ($this->onlyPrivateChanges($oldStructure, $newStructure)) {
            // Zkontroluj rozsah privátních změn
            $privateChangeImpact = $this->assessPrivateChangeImpact($oldContent, $newContent);

            if ($privateChangeImpact['is_significant']) {
                return [
                    'should_regenerate' => true,
                    'confidence' => 0.7,
                    'reason' => 'significant_private_changes',
                    'reasoning' => ['Významné změny v privátních metodách mohou ovlivnit celkovou funkcionalitu'],
                    'change_summary' => ['severity' => 'moderate'],
                    'affected_sections' => []
                ];
            } else {
                return [
                    'should_regenerate' => false,
                    'confidence' => 0.8,
                    'reason' => 'minor_private_changes',
                    'reasoning' => ['Pouze drobné změny v privátních metodách - dokumentace zůstává aktuální'],
                    'change_summary' => ['severity' => 'minor'],
                    'affected_sections' => []
                ];
            }
        }

        // 3. Změny ve veřejných metodách = generuj
        if ($this->hasPublicApiChanges($oldStructure, $newStructure)) {
            return [
                'should_regenerate' => true,
                'confidence' => 0.95,
                'reason' => 'public_api_changes',
                'reasoning' => ['Změny ve veřejném API vyžadují aktualizaci dokumentace'],
                'change_summary' => ['severity' => 'major'],
                'affected_sections' => $this->getAffectedSections($oldStructure, $newStructure, $existingDoc)
            ];
        }

        // 4. Změny v dokumentovaných částech = generuj
        if ($this->affectsDocumentedParts($oldStructure, $newStructure, $existingDoc)) {
            return [
                'should_regenerate' => true,
                'confidence' => 0.9,
                'reason' => 'documented_parts_changed',
                'reasoning' => ['Změny ovlivňují části kódu, které jsou dokumentované'],
                'change_summary' => ['severity' => 'major'],
                'affected_sections' => $this->getAffectedSections($oldStructure, $newStructure, $existingDoc)
            ];
        }

        // 5. Strukturální změny = generuj
        if ($this->hasStructuralChanges($oldStructure, $newStructure)) {
            return [
                'should_regenerate' => true,
                'confidence' => 0.85,
                'reason' => 'structural_changes',
                'reasoning' => ['Strukturální změny (nové/odstraněné třídy, metody)'],
                'change_summary' => ['severity' => 'major'],
                'affected_sections' => $this->getAffectedSections($oldStructure, $newStructure, $existingDoc)
            ];
        }

        // 6. Fallback - při nejistotě raději generuj
        return [
            'should_regenerate' => true,
            'confidence' => 0.6,
            'reason' => 'uncertain_impact',
            'reasoning' => ['Nejasný dopad změn - pro jistotu regeneruji dokumentaci'],
            'change_summary' => ['severity' => 'unknown'],
            'affected_sections' => []
        ];
    }

    /**
     * Zkontroluj změny ve veřejných API
     */
    private function hasPublicApiChanges(array $oldStructure, array $newStructure): bool
    {
        // Porovnej veřejné metody tříd
        foreach ($newStructure['classes'] ?? [] as $newClass) {
            $oldClass = $this->findClassByName($oldStructure['classes'] ?? [], $newClass['name']);

            if (!$oldClass) {
                return true; // Nová třída
            }

            if ($this->hasPublicMethodChanges($oldClass['methods'] ?? [], $newClass['methods'] ?? [])) {
                return true;
            }
        }

        // Zkontroluj odstraněné třídy
        foreach ($oldStructure['classes'] ?? [] as $oldClass) {
            if (!$this->findClassByName($newStructure['classes'] ?? [], $oldClass['name'])) {
                return true; // Odstraněná třída
            }
        }

        return false;
    }

    /**
     * Zkontroluj zda změny ovlivňují dokumentované části
     */
    private function affectsDocumentedParts(array $oldStructure, array $newStructure, array $existingDoc): bool
    {
        if (!isset($existingDoc['documented_elements'])) {
            return false;
        }

        $documentedElements = $existingDoc['documented_elements'];

        foreach ($documentedElements as $element) {
            if (!$this->elementExistsInStructure($element, $newStructure)) {
                return true; // Dokumentovaný element byl odstraněn
            }
        }

        return false;
    }

    /**
     * Zkontroluj zda jsou pouze privátní změny
     */
    private function onlyPrivateChanges(array $oldStructure, array $newStructure): bool
    {
        // Kontrola počtu veřejných metod
        $oldPublicCount = $this->countPublicMethods($oldStructure);
        $newPublicCount = $this->countPublicMethods($newStructure);

        if ($oldPublicCount !== $newPublicCount) {
            return false; // Změnil se počet veřejných metod
        }

        // Kontrola počtu veřejných vlastností
        $oldPublicProperties = $this->countPublicProperties($oldStructure);
        $newPublicProperties = $this->countPublicProperties($newStructure);

        if ($oldPublicProperties !== $newPublicProperties) {
            return false; // Změnil se počet veřejných vlastností
        }

        // Kontrola signatur veřejných metod
        foreach ($newStructure['classes'] ?? [] as $newClass) {
            $oldClass = $this->findClassByName($oldStructure['classes'] ?? [], $newClass['name']);

            if (!$oldClass) {
                return false; // Nová třída
            }

            // Porovnej signatury veřejných metod
            if (!$this->publicMethodSignaturesMatch($oldClass['methods'] ?? [], $newClass['methods'] ?? [])) {
                return false; // Změnily se signatury veřejných metod
            }
        }

        return true; // Pouze privátní změny
    }

    /**
     * Zkontroluj strukturální změny
     */
    private function hasStructuralChanges(array $oldStructure, array $newStructure): bool
    {
        return (
            count($oldStructure['classes'] ?? []) !== count($newStructure['classes'] ?? []) ||
            count($oldStructure['functions'] ?? []) !== count($newStructure['functions'] ?? []) ||
            count($oldStructure['interfaces'] ?? []) !== count($newStructure['interfaces'] ?? []) ||
            count($oldStructure['traits'] ?? []) !== count($newStructure['traits'] ?? [])
        );
    }

    /**
     * Najdi třídu podle jména
     */
    private function findClassByName(array $classes, string $name): ?array
    {
        foreach ($classes as $class) {
            if ($class['name'] === $name) {
                return $class;
            }
        }
        return null;
    }

    /**
     * Zkontroluj změny ve veřejných metodách
     */
    private function hasPublicMethodChanges(array $oldMethods, array $newMethods): bool
    {
        $oldPublicMethods = array_filter($oldMethods, fn($m) => ($m['visibility'] ?? 'public') === 'public');
        $newPublicMethods = array_filter($newMethods, fn($m) => ($m['visibility'] ?? 'public') === 'public');

        // Kontrola počtu metod
        if (count($oldPublicMethods) !== count($newPublicMethods)) {
            return true;
        }

        // Kontrola signatur metod (parametry, návratové typy)
        foreach ($newPublicMethods as $newMethod) {
            $oldMethod = $this->findMethodByName($oldPublicMethods, $newMethod['name']);

            if (!$oldMethod) {
                return true; // Nová metoda
            }

            // Porovnej signatury
            if (!$this->methodSignaturesMatch($oldMethod, $newMethod)) {
                return true; // Změnila se signatura
            }
        }

        return false;
    }

    /**
     * Spočítej veřejné metody
     */
    private function countPublicMethods(array $structure): int
    {
        $count = 0;
        foreach ($structure['classes'] ?? [] as $class) {
            foreach ($class['methods'] ?? [] as $method) {
                if (($method['visibility'] ?? 'public') === 'public') {
                    $count++;
                }
            }
        }
        return $count;
    }

    /**
     * Spočítej veřejné vlastnosti
     */
    private function countPublicProperties(array $structure): int
    {
        $count = 0;
        foreach ($structure['classes'] ?? [] as $class) {
            foreach ($class['properties'] ?? [] as $property) {
                if (($property['visibility'] ?? 'public') === 'public') {
                    $count++;
                }
            }
        }
        return $count;
    }

    /**
     * Zkontroluj zda se signatury veřejných metod shodují
     */
    private function publicMethodSignaturesMatch(array $oldMethods, array $newMethods): bool
    {
        $oldPublicMethods = array_filter($oldMethods, fn($m) => ($m['visibility'] ?? 'public') === 'public');
        $newPublicMethods = array_filter($newMethods, fn($m) => ($m['visibility'] ?? 'public') === 'public');

        // Kontrola počtu metod
        if (count($oldPublicMethods) !== count($newPublicMethods)) {
            return false;
        }

        // Porovnej signatury každé metody
        foreach ($newPublicMethods as $newMethod) {
            $oldMethod = $this->findMethodByName($oldPublicMethods, $newMethod['name']);

            if (!$oldMethod || !$this->methodSignaturesMatch($oldMethod, $newMethod)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Najdi metodu podle názvu
     */
    private function findMethodByName(array $methods, string $name): ?array
    {
        foreach ($methods as $method) {
            if ($method['name'] === $name) {
                return $method;
            }
        }
        return null;
    }

    /**
     * Porovnej signatury dvou metod (parametry, návratový typ)
     */
    private function methodSignaturesMatch(array $oldMethod, array $newMethod): bool
    {
        // Porovnej návratový typ
        if (($oldMethod['return_type'] ?? '') !== ($newMethod['return_type'] ?? '')) {
            return false;
        }

        // Porovnej parametry
        $oldParams = $oldMethod['parameters'] ?? [];
        $newParams = $newMethod['parameters'] ?? [];

        if (count($oldParams) !== count($newParams)) {
            return false;
        }

        // Porovnej každý parametr
        for ($i = 0; $i < count($oldParams); $i++) {
            $oldParam = $oldParams[$i];
            $newParam = $newParams[$i];

            // Porovnej název parametru
            if (($oldParam['name'] ?? '') !== ($newParam['name'] ?? '')) {
                return false;
            }

            // Porovnej typ parametru
            if (($oldParam['type'] ?? '') !== ($newParam['type'] ?? '')) {
                return false;
            }

            // Porovnej default hodnotu
            if (($oldParam['default'] ?? null) !== ($newParam['default'] ?? null)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Zhodnoť dopad privátních změn
     */
    private function assessPrivateChangeImpact(string $oldContent, string $newContent): array
    {
        $oldLines = explode("\n", $oldContent);
        $newLines = explode("\n", $newContent);

        $totalLines = max(count($oldLines), count($newLines));
        $changedLines = abs(count($newLines) - count($oldLines));

        // Počítej změny v řádcích
        $diffLines = 0;
        $maxLines = max(count($oldLines), count($newLines));
        for ($i = 0; $i < $maxLines; $i++) {
            $oldLine = $oldLines[$i] ?? '';
            $newLine = $newLines[$i] ?? '';
            if (trim($oldLine) !== trim($newLine)) {
                $diffLines++;
            }
        }

        $changePercentage = $totalLines > 0 ? ($diffLines / $totalLines) * 100 : 0;

        // Hledej klíčová slova indikující významné změny
        $significantKeywords = [
            'new ', 'class ', 'function ', 'return ', 'throw ', 'catch ',
            'if (', 'else', 'switch', 'case', 'for (', 'while (', 'foreach (',
            'array_', 'json_', 'file_', 'curl_', 'http_', 'sql', 'database',
            'cache', 'session', 'config', 'env(', 'log::', 'error', 'exception'
        ];

        $keywordChanges = 0;
        $newContentLower = strtolower($newContent);
        $oldContentLower = strtolower($oldContent);

        foreach ($significantKeywords as $keyword) {
            $oldCount = substr_count($oldContentLower, $keyword);
            $newCount = substr_count($newContentLower, $keyword);
            if ($oldCount !== $newCount) {
                $keywordChanges++;
            }
        }

        // Rozhodnutí o významnosti
        $isSignificant = (
            $changePercentage > 20 ||  // Více než 20% řádků změněno
            $changedLines > 10 ||      // Více než 10 řádků přidáno/odebráno
            $keywordChanges > 3        // Více než 3 významná klíčová slova změněna
        );

        return [
            'is_significant' => $isSignificant,
            'change_percentage' => $changePercentage,
            'changed_lines' => $changedLines,
            'keyword_changes' => $keywordChanges,
            'total_lines' => $totalLines
        ];
    }

    /**
     * Zkontroluj zda element existuje ve struktuře
     */
    private function elementExistsInStructure(array $element, array $structure): bool
    {
        $type = $element['type'];
        $name = $element['name'];

        switch ($type) {
            case 'class':
                return $this->findClassByName($structure['classes'] ?? [], $name) !== null;
            case 'function':
                foreach ($structure['functions'] ?? [] as $func) {
                    if ($func['name'] === $name) return true;
                }
                return false;
            default:
                return true; // Neznámý typ - předpokládej že existuje
        }
    }

    /**
     * Získej ovlivněné sekce dokumentace
     */
    private function getAffectedSections(array $oldStructure, array $newStructure, array $existingDoc): array
    {
        $affectedSections = [];

        // Jednoduchá implementace - vrať všechny sekce pokud jsou změny
        if (isset($existingDoc['sections'])) {
            $affectedSections = array_keys($existingDoc['sections']);
        }

        return $affectedSections;
    }
}
</file>

<file path="src/DigidocsServiceProvider.php">
<?php

namespace Digihood\Digidocs;

use Illuminate\Support\ServiceProvider;
use Digihood\Digidocs\Services\MemoryService;
use Digihood\Digidocs\Agent\DocumentationAgent;
use Digihood\Digidocs\Commands\AutoDocsCommand;

class DigidocsServiceProvider extends ServiceProvider
{
    /**
     * Register any application services.
     */
    public function register(): void
    {
        $this->mergeConfigFrom(
            __DIR__.'/../config/digidocs.php',
            'digidocs'
        );

        $this->mergeConfigFrom(
            __DIR__.'/../config/pricing.php',
            'digidocs.pricing'
        );

        // Registrace služeb
        $this->app->singleton(MemoryService::class, function ($app) {
            return new MemoryService();
        });

        $this->app->singleton(DocumentationAgent::class, function ($app) {
            return new DocumentationAgent();
        });

        $this->app->singleton(Services\GitWatcherService::class, function ($app) {
            return new Services\GitWatcherService();
        });

        $this->app->singleton(Services\CostTracker::class, function ($app) {
            return new Services\CostTracker($app->make(MemoryService::class));
        });
    }

    /**
     * Bootstrap any application services.
     */
    public function boot(): void
    {
        // Registrace artisan commands
        if ($this->app->runningInConsole()) {
            $this->commands([
                AutoDocsCommand::class,
                Commands\WatchCommand::class,
            ]);
        }

        // Publikace konfiguračních souborů
        $this->publishes([
            __DIR__.'/../config/digidocs.php' => config_path('digidocs.php'),
            __DIR__.'/../config/pricing.php' => config_path('digidocs/pricing.php'),
        ], 'digidocs-config');

        // Publikace views
        $this->publishes([
            __DIR__.'/../resources/views' => resource_path('views/vendor/digidocs'),
        ], 'digidocs-views');

        // Publikace migrací
        $this->publishes([
            __DIR__.'/../database/migrations' => database_path('migrations'),
        ], 'digidocs-migrations');

        // Načtení views
        $this->loadViewsFrom(__DIR__.'/../resources/views', 'digidocs');

        // Načtení migrací
        $this->loadMigrationsFrom(__DIR__.'/../database/migrations');
    }
}
</file>

<file path="src/Services/MemoryService.php">
<?php

namespace Digihood\Digidocs\Services;

use PDO;
use PDOException;
use Illuminate\Support\Facades\File;

class MemoryService
{
    private PDO $db;
    private string $dbPath;

    public function __construct()
    {
        $this->dbPath = config('digidocs.paths.memory') . '/memory.sqlite';
        $this->ensureDatabase();
        $this->db = new PDO("sqlite:" . $this->dbPath);
        $this->db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        $this->upgradeDatabase();
    }

    /**
     * Zkontroluje zda soubor potřebuje novou dokumentaci (klasická metoda)
     */
    public function needsDocumentation(string $filePath): array
    {
        $fullPath = base_path($filePath);

        if (!file_exists($fullPath)) {
            return [
                'needs_update' => false,
                'is_new' => false,
                'error' => 'File not found'
            ];
        }

        $currentHash = hash_file('sha256', $fullPath);

        $stmt = $this->db->prepare("
            SELECT file_hash, last_documented_at, documentation_path
            FROM documented_files
            WHERE file_path = ?
        ");
        $stmt->execute([$filePath]);
        $existing = $stmt->fetch(PDO::FETCH_ASSOC);

        return [
            'needs_update' => !$existing || $existing['file_hash'] !== $currentHash,
            'is_new' => !$existing,
            'current_hash' => $currentHash,
            'last_hash' => $existing['file_hash'] ?? null,
            'doc_path' => $existing['documentation_path'] ?? null,
            'last_documented_at' => $existing['last_documented_at'] ?? null
        ];
    }

    /**
     * Zaznamenej analýzu do databáze pro debugging a statistiky
     * (používá se z ChangeAnalysisAgent)
     */
    public function recordAnalysis(string $filePath, string $hash, array $analysis): void
    {
        try {
            $stmt = $this->db->prepare("
                INSERT OR REPLACE INTO change_analysis
                (file_path, file_hash, should_regenerate, confidence, reason, semantic_score, analysis_data, analyzed_at, existing_doc_path, doc_relevance_score, affected_doc_sections)
                VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'), ?, ?, ?)
            ");

            $stmt->execute([
                $filePath,
                $hash,
                $analysis['should_regenerate'] ? 1 : 0,
                $analysis['confidence'] ?? 0,
                $analysis['reason'] ?? 'unknown',
                $analysis['semantic_score'] ?? 0,
                json_encode($analysis),
                $analysis['existing_doc_path'] ?? null,
                $analysis['doc_relevance_score'] ?? null,
                isset($analysis['affected_doc_sections']) ? json_encode($analysis['affected_doc_sections']) : null
            ]);
        } catch (\Exception $e) {
            // Ignoruj chyby při záznamu analýzy
            \Log::warning("Failed to record analysis: " . $e->getMessage());
        }
    }

    /**
     * Zaznamenej dokumentované části kódu
     */
    public function recordDocumentedCodeParts(string $filePath, array $codeParts): void
    {
        try {
            // Nejprve smaž staré záznamy pro tento soubor
            $stmt = $this->db->prepare("DELETE FROM documented_code_parts WHERE file_path = ?");
            $stmt->execute([$filePath]);

            // Vlož nové záznamy
            $stmt = $this->db->prepare("
                INSERT INTO documented_code_parts
                (file_path, code_type, code_name, code_signature, documented_in_section, last_updated_at)
                VALUES (?, ?, ?, ?, ?, datetime('now'))
            ");

            foreach ($codeParts as $part) {
                $stmt->execute([
                    $filePath,
                    $part['type'] ?? 'unknown',
                    $part['name'] ?? '',
                    $part['signature'] ?? null,
                    $part['section'] ?? null
                ]);
            }
        } catch (\Exception $e) {
            \Log::warning("Failed to record documented code parts for {$filePath}: " . $e->getMessage());
        }
    }

    /**
     * Získej dokumentované části kódu pro soubor
     */
    public function getDocumentedCodeParts(string $filePath): array
    {
        try {
            $stmt = $this->db->prepare("
                SELECT code_type, code_name, code_signature, documented_in_section, last_updated_at
                FROM documented_code_parts
                WHERE file_path = ?
                ORDER BY code_type, code_name
            ");
            $stmt->execute([$filePath]);

            return $stmt->fetchAll(\PDO::FETCH_ASSOC) ?: [];
        } catch (\Exception $e) {
            \Log::warning("Failed to get documented code parts for {$filePath}: " . $e->getMessage());
            return [];
        }
    }

    /**
     * Zaznamená vygenerovanou dokumentaci
     */
    public function recordDocumentation(string $filePath, string $hash, string $docPath): void
    {
        $stmt = $this->db->prepare("
            INSERT OR REPLACE INTO documented_files
            (file_path, file_hash, documentation_path, last_documented_at)
            VALUES (?, ?, ?, datetime('now'))
        ");
        $stmt->execute([$filePath, $hash, $docPath]);
    }

    /**
     * Získá statistiky dokumentace
     */
    public function getStats(): array
    {
        $stmt = $this->db->query("
            SELECT
                COUNT(*) as total_files,
                COUNT(CASE WHEN datetime(last_documented_at) > datetime('now', '-7 days') THEN 1 END) as recent_updates
            FROM documented_files
        ");

        $basicStats = $stmt->fetch(PDO::FETCH_ASSOC) ?: ['total_files' => 0, 'recent_updates' => 0];

        // Přidej statistiky inteligentní analýzy
        $analysisStats = $this->getAnalysisStats();

        return array_merge($basicStats, $analysisStats);
    }

    /**
     * Získá statistiky nákladů a tokenů
     */
    public function getCostStats(): array
    {
        try {
            // Základní statistiky
            $stmt = $this->db->query("
                SELECT
                    COUNT(*) as total_calls,
                    SUM(input_tokens) as total_input_tokens,
                    SUM(output_tokens) as total_output_tokens,
                    SUM(total_tokens) as total_tokens,
                    SUM(cost) as total_cost
                FROM token_usage
            ");

            $basicStats = $stmt->fetch(PDO::FETCH_ASSOC) ?: [
                'total_calls' => 0,
                'total_input_tokens' => 0,
                'total_output_tokens' => 0,
                'total_tokens' => 0,
                'total_cost' => 0.0
            ];

            // Statistiky podle modelů
            $stmt = $this->db->query("
                SELECT
                    model,
                    COUNT(*) as calls,
                    SUM(input_tokens) as input_tokens,
                    SUM(output_tokens) as output_tokens,
                    SUM(total_tokens) as total_tokens,
                    SUM(cost) as cost
                FROM token_usage
                GROUP BY model
                ORDER BY cost DESC
            ");

            $byModel = [];
            while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
                $byModel[$row['model']] = [
                    'calls' => (int) $row['calls'],
                    'input_tokens' => (int) $row['input_tokens'],
                    'output_tokens' => (int) $row['output_tokens'],
                    'total_tokens' => (int) $row['total_tokens'],
                    'cost' => (float) $row['cost']
                ];
            }

            // Nedávná aktivita (posledních 7 dní)
            $stmt = $this->db->query("
                SELECT
                    COUNT(*) as calls,
                    SUM(total_tokens) as tokens,
                    SUM(cost) as cost
                FROM token_usage
                WHERE datetime(created_at) > datetime('now', '-7 days')
            ");

            $recentActivity = $stmt->fetch(PDO::FETCH_ASSOC) ?: [
                'calls' => 0,
                'tokens' => 0,
                'cost' => 0.0
            ];

            return [
                'total_calls' => (int) $basicStats['total_calls'],
                'total_input_tokens' => (int) $basicStats['total_input_tokens'],
                'total_output_tokens' => (int) $basicStats['total_output_tokens'],
                'total_tokens' => (int) $basicStats['total_tokens'],
                'total_cost' => (float) $basicStats['total_cost'],
                'by_model' => $byModel,
                'recent_activity' => [
                    'calls' => (int) $recentActivity['calls'],
                    'tokens' => (int) $recentActivity['tokens'],
                    'cost' => (float) $recentActivity['cost']
                ]
            ];

        } catch (\Exception $e) {
            return [
                'total_calls' => 0,
                'total_input_tokens' => 0,
                'total_output_tokens' => 0,
                'total_tokens' => 0,
                'total_cost' => 0.0,
                'by_model' => [],
                'recent_activity' => ['calls' => 0, 'tokens' => 0, 'cost' => 0.0],
                'error' => $e->getMessage()
            ];
        }
    }

    /**
     * Zaznamenej použití tokenů
     */
    public function recordTokenUsage(string $model, int $inputTokens, int $outputTokens, float $cost, ?string $filePath = null): void
    {
        try {
            $stmt = $this->db->prepare("
                INSERT INTO token_usage
                (model, input_tokens, output_tokens, total_tokens, cost, file_path, created_at)
                VALUES (?, ?, ?, ?, ?, ?, datetime('now'))
            ");

            $stmt->execute([
                $model,
                $inputTokens,
                $outputTokens,
                $inputTokens + $outputTokens,
                $cost,
                $filePath
            ]);
        } catch (\Exception $e) {
            \Log::warning("Failed to record token usage: " . $e->getMessage());
        }
    }

    /**
     * Získá statistiky inteligentní analýzy
     */
    public function getAnalysisStats(): array
    {
        try {
            $stmt = $this->db->query("
                SELECT
                    COUNT(*) as total_analyses,
                    COUNT(CASE WHEN should_regenerate = 1 THEN 1 END) as regeneration_recommended,
                    COUNT(CASE WHEN should_regenerate = 0 THEN 1 END) as regeneration_skipped,
                    AVG(confidence) as avg_confidence,
                    AVG(semantic_score) as avg_semantic_score,
                    COUNT(CASE WHEN datetime(analyzed_at) > datetime('now', '-24 hours') THEN 1 END) as recent_analyses
                FROM change_analysis
            ");

            $stats = $stmt->fetch(PDO::FETCH_ASSOC);

            if (!$stats || $stats['total_analyses'] == 0) {
                return [
                    'analysis_enabled' => config('digidocs.intelligent_analysis.enabled', true),
                    'total_analyses' => 0,
                    'regeneration_recommended' => 0,
                    'regeneration_skipped' => 0,
                    'skip_rate' => 0.0,
                    'avg_confidence' => 0.0,
                    'avg_semantic_score' => 0.0,
                    'recent_analyses' => 0
                ];
            }

            $skipRate = $stats['total_analyses'] > 0
                ? round(($stats['regeneration_skipped'] / $stats['total_analyses']) * 100, 1)
                : 0.0;

            return [
                'analysis_enabled' => config('digidocs.intelligent_analysis.enabled', true),
                'total_analyses' => (int) $stats['total_analyses'],
                'regeneration_recommended' => (int) $stats['regeneration_recommended'],
                'regeneration_skipped' => (int) $stats['regeneration_skipped'],
                'skip_rate' => $skipRate,
                'avg_confidence' => round((float) $stats['avg_confidence'], 3),
                'avg_semantic_score' => round((float) $stats['avg_semantic_score'], 1),
                'recent_analyses' => (int) $stats['recent_analyses']
            ];

        } catch (\Exception $e) {
            return [
                'analysis_enabled' => false,
                'error' => $e->getMessage()
            ];
        }
    }

    /**
     * Smaže záznamy pro neexistující soubory
     */
    public function cleanup(): int
    {
        $stmt = $this->db->query("SELECT file_path FROM documented_files");
        $files = $stmt->fetchAll(PDO::FETCH_COLUMN);

        $deleted = 0;
        foreach ($files as $file) {
            if (!file_exists(base_path($file))) {
                $deleteStmt = $this->db->prepare("DELETE FROM documented_files WHERE file_path = ?");
                $deleteStmt->execute([$file]);
                $deleted++;
            }
        }

        return $deleted;
    }

    /**
     * Získá posledně zpracovaný Git commit
     */
    public function getLastProcessedCommit(): ?string
    {
        $stmt = $this->db->prepare("
            SELECT commit_hash
            FROM git_commits
            ORDER BY processed_at DESC
            LIMIT 1
        ");
        $stmt->execute();
        $result = $stmt->fetch(PDO::FETCH_ASSOC);

        return $result ? $result['commit_hash'] : null;
    }

    /**
     * Uloží posledně zpracovaný Git commit
     */
    public function setLastProcessedCommit(string $commitHash): void
    {
        $stmt = $this->db->prepare("
            INSERT OR REPLACE INTO git_commits
            (commit_hash, processed_at)
            VALUES (?, datetime('now'))
        ");
        $stmt->execute([$commitHash]);
    }

    /**
     * Zkontroluje jestli už byly nějaké soubory zpracovány
     */
    public function hasAnyDocumentedFiles(): bool
    {
        $stmt = $this->db->prepare("SELECT COUNT(*) FROM documented_files");
        $stmt->execute();
        $count = $stmt->fetchColumn();

        return $count > 0;
    }

    /**
     * Získá seznam všech zpracovaných souborů
     */
    public function getDocumentedFiles(): array
    {
        $stmt = $this->db->prepare("SELECT file_path FROM documented_files");
        $stmt->execute();

        return $stmt->fetchAll(PDO::FETCH_COLUMN);
    }

    /**
     * Zajistí existenci databáze a vytvoří tabulky
     */
    private function ensureDatabase(): void
    {
        $dir = dirname($this->dbPath);
        if (!File::exists($dir)) {
            File::makeDirectory($dir, 0755, true);
        }

        if (!file_exists($this->dbPath)) {
            $this->createDatabase();
        }
    }

    /**
     * Vytvoří databázi a tabulky
     */
    private function createDatabase(): void
    {
        try {
            $db = new PDO("sqlite:" . $this->dbPath);
            $db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

            $db->exec("
                CREATE TABLE IF NOT EXISTS documented_files (
                    file_path TEXT PRIMARY KEY,
                    file_hash TEXT NOT NULL,
                    documentation_path TEXT,
                    last_documented_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            ");

            $db->exec("
                CREATE INDEX IF NOT EXISTS idx_last_documented
                ON documented_files(last_documented_at)
            ");

            $db->exec("
                CREATE TABLE IF NOT EXISTS git_commits (
                    commit_hash TEXT PRIMARY KEY,
                    processed_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            ");

            $db->exec("
                CREATE INDEX IF NOT EXISTS idx_processed_at
                ON git_commits(processed_at)
            ");

            // Tabulka pro analýzu změn
            $db->exec("
                CREATE TABLE IF NOT EXISTS change_analysis (
                    file_path TEXT,
                    file_hash TEXT,
                    should_regenerate INTEGER NOT NULL,
                    confidence REAL NOT NULL,
                    reason TEXT,
                    semantic_score INTEGER,
                    analysis_data TEXT,
                    analyzed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    existing_doc_path TEXT,
                    doc_relevance_score INTEGER,
                    affected_doc_sections TEXT,
                    PRIMARY KEY (file_path, file_hash)
                )
            ");

            $db->exec("
                CREATE INDEX IF NOT EXISTS idx_change_analysis_analyzed_at
                ON change_analysis(analyzed_at)
            ");

            // Nová tabulka pro tracking dokumentovaných částí kódu
            $db->exec("
                CREATE TABLE IF NOT EXISTS documented_code_parts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    file_path TEXT NOT NULL,
                    code_type TEXT NOT NULL,
                    code_name TEXT NOT NULL,
                    code_signature TEXT,
                    documented_in_section TEXT,
                    last_updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(file_path, code_type, code_name)
                )
            ");

            $db->exec("
                CREATE INDEX IF NOT EXISTS idx_documented_code_parts_file_path
                ON documented_code_parts(file_path)
            ");

            $db->exec("
                CREATE INDEX IF NOT EXISTS idx_documented_code_parts_updated_at
                ON documented_code_parts(last_updated_at)
            ");

            // Tabulka pro sledování tokenů a nákladů
            $db->exec("
                CREATE TABLE IF NOT EXISTS token_usage (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    model TEXT NOT NULL,
                    input_tokens INTEGER NOT NULL,
                    output_tokens INTEGER NOT NULL,
                    total_tokens INTEGER NOT NULL,
                    cost REAL NOT NULL,
                    file_path TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            ");

            $db->exec("
                CREATE INDEX IF NOT EXISTS idx_token_usage_created_at
                ON token_usage(created_at)
            ");

            $db->exec("
                CREATE INDEX IF NOT EXISTS idx_token_usage_model
                ON token_usage(model)
            ");

            $db->exec("
                CREATE INDEX IF NOT EXISTS idx_token_usage_file_path
                ON token_usage(file_path)
            ");

        } catch (PDOException $e) {
            throw new \RuntimeException("Nelze vytvořit AutoDocs databázi: " . $e->getMessage());
        }
    }

    /**
     * Upgraduje existující databázi (přidá nové tabulky)
     */
    private function upgradeDatabase(): void
    {
        try {
            // Zkontroluj jestli git_commits tabulka existuje
            $stmt = $this->db->query("
                SELECT name FROM sqlite_master
                WHERE type='table' AND name='git_commits'
            ");

            if (!$stmt->fetch()) {
                // Vytvoř git_commits tabulku
                $this->db->exec("
                    CREATE TABLE git_commits (
                        commit_hash TEXT PRIMARY KEY,
                        processed_at DATETIME DEFAULT CURRENT_TIMESTAMP
                    )
                ");

                $this->db->exec("
                    CREATE INDEX idx_processed_at
                    ON git_commits(processed_at)
                ");
            }

            // Zkontroluj jestli change_analysis tabulka existuje
            $stmt = $this->db->query("
                SELECT name FROM sqlite_master
                WHERE type='table' AND name='change_analysis'
            ");

            if (!$stmt->fetch()) {
                // Vytvoř change_analysis tabulku s novými sloupci
                $this->db->exec("
                    CREATE TABLE change_analysis (
                        file_path TEXT,
                        file_hash TEXT,
                        should_regenerate INTEGER NOT NULL,
                        confidence REAL NOT NULL,
                        reason TEXT,
                        semantic_score INTEGER,
                        analysis_data TEXT,
                        analyzed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        existing_doc_path TEXT,
                        doc_relevance_score INTEGER,
                        affected_doc_sections TEXT,
                        PRIMARY KEY (file_path, file_hash)
                    )
                ");

                $this->db->exec("
                    CREATE INDEX idx_change_analysis_analyzed_at
                    ON change_analysis(analyzed_at)
                ");
            } else {
                // Upgrade existující tabulky - přidej nové sloupce pokud neexistují
                try {
                    $this->db->exec("ALTER TABLE change_analysis ADD COLUMN existing_doc_path TEXT");
                } catch (\Exception $e) {
                    // Sloupec už existuje
                }
                try {
                    $this->db->exec("ALTER TABLE change_analysis ADD COLUMN doc_relevance_score INTEGER");
                } catch (\Exception $e) {
                    // Sloupec už existuje
                }
                try {
                    $this->db->exec("ALTER TABLE change_analysis ADD COLUMN affected_doc_sections TEXT");
                } catch (\Exception $e) {
                    // Sloupec už existuje
                }
            }

            // Zkontroluj a vytvoř documented_code_parts tabulku
            $stmt = $this->db->prepare("SELECT name FROM sqlite_master WHERE type='table' AND name='documented_code_parts'");
            $stmt->execute();

            if (!$stmt->fetch()) {
                $this->db->exec("
                    CREATE TABLE documented_code_parts (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        file_path TEXT NOT NULL,
                        code_type TEXT NOT NULL,
                        code_name TEXT NOT NULL,
                        code_signature TEXT,
                        documented_in_section TEXT,
                        last_updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        UNIQUE(file_path, code_type, code_name)
                    )
                ");

                $this->db->exec("
                    CREATE INDEX idx_documented_code_parts_file_path
                    ON documented_code_parts(file_path)
                ");

                $this->db->exec("
                    CREATE INDEX idx_documented_code_parts_updated_at
                    ON documented_code_parts(last_updated_at)
                ");
            }

            // Zkontroluj a vytvoř token_usage tabulku
            $stmt = $this->db->prepare("SELECT name FROM sqlite_master WHERE type='table' AND name='token_usage'");
            $stmt->execute();

            if (!$stmt->fetch()) {
                $this->db->exec("
                    CREATE TABLE token_usage (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        model TEXT NOT NULL,
                        input_tokens INTEGER NOT NULL,
                        output_tokens INTEGER NOT NULL,
                        total_tokens INTEGER NOT NULL,
                        cost REAL NOT NULL,
                        file_path TEXT,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                    )
                ");

                $this->db->exec("
                    CREATE INDEX idx_token_usage_created_at
                    ON token_usage(created_at)
                ");

                $this->db->exec("
                    CREATE INDEX idx_token_usage_model
                    ON token_usage(model)
                ");

                $this->db->exec("
                    CREATE INDEX idx_token_usage_file_path
                    ON token_usage(file_path)
                ");
            }
        } catch (PDOException $e) {
            // Ignoruj chyby při upgrade - databáze může být již aktuální
        }
    }
}
</file>

<file path="src/Commands/AutoDocsCommand.php">
<?php

namespace Digihood\Digidocs\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;
use Digihood\Digidocs\Services\MemoryService;
use Digihood\Digidocs\Agent\DocumentationAgent;
use Digihood\Digidocs\Agent\ChangeAnalysisAgent;
use Digihood\Digidocs\Services\GitWatcherService;
use Digihood\Digidocs\Services\CostTracker;
use Exception;

class AutoDocsCommand extends Command
{
    protected $signature = 'digidocs:autodocs {--force : Force regeneration of all documentation}
                                    {--dry-run : Show what would be processed without generating documentation}
                                    {--cleanup : Clean up memory database from non-existent files}
                                    {--stats : Show documentation statistics}
                                    {--cost : Show token usage and cost statistics}
                                    {--path=* : Specific paths to process}';

    protected $description = 'Generate documentation using AI agent for PHP files changed in Git commits';

    public function __construct(
        private MemoryService $memory,
        private DocumentationAgent $agent,
        private ChangeAnalysisAgent $changeAgent,
        private GitWatcherService $gitWatcher,
        private CostTracker $costTracker
    ) {
        parent::__construct();

        // Nastaví cost tracking pro agenty
        $this->agent->setCostTracker($this->costTracker);
        $this->changeAgent->setCostTracker($this->costTracker);
    }

    public function handle(): int
    {
        $this->info('🤖 AutoDocs AI Agent - Starting...');

        // Statistiky
        if ($this->option('stats')) {
            return $this->showStats();
        }

        // Statistiky nákladů
        if ($this->option('cost')) {
            return $this->showCostStats();
        }

        // Cleanup
        if ($this->option('cleanup')) {
            return $this->cleanup();
        }

        // Zkontroluj Git dostupnost
        if (!$this->gitWatcher->isGitAvailable()) {
            $this->error("❌ Git repository not available. Ensure you're in a Git repository.");
            return 1;
        }

        // Získej seznam souborů k analýze
        $files = $this->getFilesToProcess();

        if (empty($files)) {
            $this->info('📭 No changed PHP files found in recent Git commits.');
            return 0;
        }

        $this->line("📋 Found " . count($files) . " PHP files to check (mode: Git changes)");

        $processed = 0;
        $skipped = 0;
        $errors = 0;

        foreach ($files as $filePath) {
            $result = $this->processFile($filePath);

            switch ($result) {
                case 'processed':
                    $processed++;
                    break;
                case 'skipped':
                    $skipped++;
                    break;
                case 'error':
                    $errors++;
                    break;
            }
        }

        // Shrnutí
        $this->newLine();
        $this->info("✅ Dokončeno!");
        $this->line("📊 Zpracováno: {$processed}, Přeskočeno: {$skipped}, Chyb: {$errors}");

        return $errors > 0 ? 1 : 0;
    }

    /**
     * Zpracuje jednotlivý soubor
     */
    private function processFile(string $filePath): string
    {
        $this->line("📄 Processing: {$filePath}");

        try {
            // Převeď absolutní cestu na relativní
            $relativePath = str_replace(base_path() . DIRECTORY_SEPARATOR, '', $filePath);
            $relativePath = str_replace('\\', '/', $relativePath);

            if ($this->option('dry-run')) {
                $this->line("   🔍 Would process with ChangeAnalysisAgent");
                return 'processed';
            }

            // Použij ChangeAnalysisAgent pro inteligentní rozhodování s retry logikou
            $documentation = $this->generateDocumentationWithRetry($relativePath);

            if ($documentation === null) {
                $this->line("   ⏭️  Skipped (no significant changes)");
                return 'skipped';
            }

            // Ulož dokumentaci
            $docPath = $this->saveDocumentation($relativePath, $documentation);

            // NOVÉ: Zaznamenej dokumentované části kódu
            $this->recordDocumentedCodeParts($relativePath, $documentation);

            // Zaznamenej do memory pouze pokud se vše podařilo
            $currentHash = hash_file('sha256', base_path($relativePath));
            $this->memory->recordDocumentation(
                $relativePath,
                $currentHash,
                $docPath
            );

            $this->line("   ✅ Generated: {$docPath}");
            return 'processed';

        } catch (Exception $e) {
            $this->line("   ❌ Failed: " . $e->getMessage());
            return 'error';
        }
    }

    /**
     * Generuje dokumentaci s retry logikou pro 429 chyby
     */
    private function generateDocumentationWithRetry(string $relativePath): ?string
    {
        $maxRetries = 3;
        $retryDelays = [10, 30, 60]; // sekundy

        for ($attempt = 0; $attempt <= $maxRetries; $attempt++) {
            try {
                // KLÍČOVÁ OPRAVA: Vytvoř novou instanci agenta pro každý pokus
                // Tím se vyčistí stav konverzace a vyřeší se problém s Tools
                $changeAgent = new \Digihood\Digidocs\Agent\ChangeAnalysisAgent();

                // Nastav cost tracker pokud je dostupný
                if ($this->costTracker) {
                    $changeAgent->setCostTracker($this->costTracker);
                }

                return $changeAgent->generateDocumentationIfNeeded($relativePath);
            } catch (\Exception $e) {
                // Zkontroluj jestli je to retryable chyba
                if ($this->isRetryableError($e)) {
                    if ($attempt < $maxRetries) {
                        $delay = $retryDelays[$attempt];
                        $errorType = $this->getErrorType($e);
                        $this->line("   ⏳ {$errorType}, retrying in {$delay}s (attempt " . ($attempt + 2) . "/" . ($maxRetries + 1) . ")");
                        sleep($delay);
                        continue;
                    } else {
                        $errorType = $this->getErrorType($e);
                        $this->line("   ❌ {$errorType} exceeded after {$maxRetries} retries");
                        throw $e;
                    }
                } else {
                    // Pro jiné chyby neprovádíme retry
                    $errorType = $this->getErrorType($e);
                    $this->line("   ❌ Non-retryable error ({$errorType}): " . substr($e->getMessage(), 0, 100) . "...");
                    throw $e;
                }
            }
        }

        return null;
    }

    /**
     * Zkontroluje jestli je chyba retryable (rate limit nebo tool message chyby)
     */
    private function isRetryableError(\Exception $e): bool
    {
        return $this->isRateLimitError($e) || $this->isToolMessageError($e);
    }

    /**
     * Zkontroluje jestli je chyba způsobená rate limitem
     */
    private function isRateLimitError(\Exception $e): bool
    {
        $message = $e->getMessage();

        // Zkontroluj různé typy rate limit chyb
        return str_contains($message, '429 Too Many Requests') ||
               str_contains($message, 'Rate limit reached') ||
               str_contains($message, 'rate_limit_exceeded') ||
               str_contains($message, 'quota_exceeded');
    }

    /**
     * Zkontroluje jestli je chyba způsobená nesprávnou sekvencí tool messages
     */
    private function isToolMessageError(\Exception $e): bool
    {
        $message = $e->getMessage();

        // Zkontroluj chyby s tool messages
        return str_contains($message, 'messages with role') ||
               str_contains($message, 'tool\' must be a response') ||
               str_contains($message, 'Invalid parameter: messages');
    }

    /**
     * Určí typ chyby pro lepší debugging
     */
    private function getErrorType(\Exception $e): string
    {
        $message = $e->getMessage();

        if (str_contains($message, '400 Bad Request')) {
            return '400 Bad Request';
        } elseif (str_contains($message, '401 Unauthorized')) {
            return '401 Unauthorized';
        } elseif (str_contains($message, '403 Forbidden')) {
            return '403 Forbidden';
        } elseif (str_contains($message, '429 Too Many Requests')) {
            return '429 Rate Limit';
        } elseif (str_contains($message, '500 Internal Server Error')) {
            return '500 Server Error';
        } elseif (str_contains($message, 'Invalid parameter')) {
            return 'Invalid Parameter';
        } elseif (str_contains($message, 'messages with role') || str_contains($message, 'tool\' must be a response')) {
            return 'Tool Message Sequence Error';
        } else {
            return 'Unknown';
        }
    }

    /**
     * Uloží dokumentaci do souboru
     */
    private function saveDocumentation(string $filePath, string $documentation): string
    {
        $docsPath = config('digidocs.paths.docs');

        // Převeď cestu souboru na cestu dokumentace
        $relativePath = str_replace(['app/', '.php'], ['', '.md'], $filePath);
        $docPath = $docsPath . '/' . $relativePath;

        // Zajisti existenci adresáře
        $directory = dirname($docPath);
        if (!File::exists($directory)) {
            File::makeDirectory($directory, 0755, true);
        }

        // Uloř dokumentaci
        File::put($docPath, $documentation);

        return str_replace(base_path() . '/', '', $docPath);
    }

    /**
     * Zaznamenej dokumentované části kódu
     */
    private function recordDocumentedCodeParts(string $filePath, string $documentation): void
    {
        try {
            // Parsuj současný kód pro získání struktury
            $documentationAnalyzer = new \Digihood\Digidocs\Services\DocumentationAnalyzer();
            $currentContent = file_get_contents(base_path($filePath));

            if (!$currentContent) {
                return;
            }

            $codeStructure = $documentationAnalyzer->parseCodeStructure($currentContent);
            $codeParts = [];

            // Extrahuj třídy
            foreach ($codeStructure['classes'] ?? [] as $class) {
                $codeParts[] = [
                    'type' => 'class',
                    'name' => $class['name'],
                    'signature' => $this->buildClassSignature($class),
                    'section' => 'Classes'
                ];

                // Extrahuj veřejné metody
                foreach ($class['methods'] ?? [] as $method) {
                    if (($method['visibility'] ?? 'public') === 'public') {
                        $codeParts[] = [
                            'type' => 'method',
                            'name' => $class['name'] . '::' . $method['name'],
                            'signature' => $this->buildMethodSignature($method),
                            'section' => 'Methods'
                        ];
                    }
                }

                // Extrahuj veřejné vlastnosti
                foreach ($class['properties'] ?? [] as $property) {
                    if (($property['visibility'] ?? 'public') === 'public') {
                        $codeParts[] = [
                            'type' => 'property',
                            'name' => $class['name'] . '::$' . $property['name'],
                            'signature' => $property['visibility'] . ' $' . $property['name'],
                            'section' => 'Properties'
                        ];
                    }
                }
            }

            // Extrahuj funkce
            foreach ($codeStructure['functions'] ?? [] as $function) {
                $codeParts[] = [
                    'type' => 'function',
                    'name' => $function['name'],
                    'signature' => $this->buildFunctionSignature($function),
                    'section' => 'Functions'
                ];
            }

            // Zaznamenej do databáze
            $this->memory->recordDocumentedCodeParts($filePath, $codeParts);

        } catch (\Exception $e) {
            \Log::warning("Failed to record documented code parts for {$filePath}: " . $e->getMessage());
        }
    }

    /**
     * Vytvoř signaturu třídy
     */
    private function buildClassSignature(array $class): string
    {
        $signature = 'class ' . $class['name'];

        if (!empty($class['extends'])) {
            $signature .= ' extends ' . $class['extends'];
        }

        if (!empty($class['implements'])) {
            $signature .= ' implements ' . implode(', ', $class['implements']);
        }

        return $signature;
    }

    /**
     * Vytvoř signaturu metody
     */
    private function buildMethodSignature(array $method): string
    {
        $params = [];
        foreach ($method['parameters'] ?? [] as $param) {
            $paramStr = '';
            if ($param['type']) {
                $paramStr .= $param['type'] . ' ';
            }
            $paramStr .= '$' . $param['name'];
            if ($param['default']) {
                $paramStr .= ' = ...';
            }
            $params[] = $paramStr;
        }

        $signature = ($method['visibility'] ?? 'public') . ' function ' . $method['name'] . '(' . implode(', ', $params) . ')';

        if ($method['return_type']) {
            $signature .= ': ' . $method['return_type'];
        }

        return $signature;
    }

    /**
     * Vytvoř signaturu funkce
     */
    private function buildFunctionSignature(array $function): string
    {
        $params = [];
        foreach ($function['parameters'] ?? [] as $param) {
            $paramStr = '';
            if ($param['type']) {
                $paramStr .= $param['type'] . ' ';
            }
            $paramStr .= '$' . $param['name'];
            if ($param['default']) {
                $paramStr .= ' = ...';
            }
            $params[] = $paramStr;
        }

        $signature = 'function ' . $function['name'] . '(' . implode(', ', $params) . ')';

        if ($function['return_type']) {
            $signature .= ': ' . $function['return_type'];
        }

        return $signature;
    }

    /**
     * Získá seznam souborů k zpracování
     */
    private function getFilesToProcess(): array
    {
        return $this->getGitChangedFiles();
    }

    /**
     * Získá soubory změněné v Git commitech
     */
    private function getGitChangedFiles(): array
    {
        if (!$this->gitWatcher->isGitAvailable()) {
            return [];
        }

        $watchPaths = $this->option('path') ?: config('digidocs.paths.watch', ['app/']);

        // Získej posledně zpracovaný commit z memory
        $lastProcessedCommit = $this->memory->getLastProcessedCommit();
        $currentCommit = $this->gitWatcher->getCurrentCommitHashes();

        // Zkontroluj jestli už byly nějaké soubory zpracovány
        $hasDocumentedFiles = $this->memory->hasAnyDocumentedFiles();

        // Pokud je to první spuštění (žádné zpracované soubory), zpracuj všechny commity
        if (!$hasDocumentedFiles) {
            if (empty($currentCommit)) {
                $this->line("📭 No Git repository available for first run.");
                return [];
            }

            $this->line("🔍 First run detected - processing all commits in Git history...");
            $changedFiles = $this->getAllChangedFilesFromHistory($watchPaths);

            $currentCommitHash = array_values($currentCommit)[0];
            $this->memory->setLastProcessedCommit($currentCommitHash);
        } else {
            // Pro další spuštění potřebujeme Git
            if (empty($currentCommit)) {
                $this->line("📭 No Git commits available for change detection.");
                return [];
            }

            $currentCommitHash = array_values($currentCommit)[0];

            if ($this->option('force')) {
                $this->line("🔍 Force mode - processing files from current commit...");
                $changedFiles = $this->gitWatcher->getChangedFilesInCommit($currentCommitHash, $currentCommitHash . '~1');
            } else if ($lastProcessedCommit !== $currentCommitHash) {
                $this->line("🔍 Processing files changed since last run...");
                $changedFiles = $this->gitWatcher->getChangedFilesInCommit($currentCommitHash, $lastProcessedCommit);
            } else {
                // Zkontroluj jestli jsou nějaké soubory, které selhaly při předchozím zpracování
                $failedFiles = $this->getFailedFiles($watchPaths);
                if (!empty($failedFiles)) {
                    $this->line("🔄 Retrying " . count($failedFiles) . " files that failed in previous runs...");
                    $changedFiles = $failedFiles;
                } else {
                    $this->line("📭 No new commits since last run.");
                    return [];
                }
            }

            // Uložit aktuální commit jako zpracovaný
            $this->memory->setLastProcessedCommit($currentCommitHash);
        }

        // Filtruj soubory podle konfigurace (pouze pokud nejsou už předfiltrované)
        if (!$hasDocumentedFiles) {
            // Pro první spuštění už máme správné soubory
            $filteredFiles = $changedFiles;
        } else {
            // Pro ostatní případy filtruj podle konfigurace
            $filteredFiles = $this->filterChangedFiles($changedFiles, $watchPaths);
        }

        return $filteredFiles;
    }

    /**
     * Získá všechny soubory změněné v celé Git historii (pro první spuštění)
     */
    private function getAllChangedFilesFromHistory(array $watchPaths): array
    {
        if (!$this->gitWatcher->isGitAvailable()) {
            return [];
        }

        try {
            // Získej všechny PHP soubory změněné v celé historii
            $allChangedFiles = $this->gitWatcher->getAllChangedFilesInHistory();

            // Filtruj podle sledovaných cest a PHP rozšíření
            $filteredFiles = $this->filterChangedFiles($allChangedFiles, $watchPaths);

            $this->line("📊 Found " . count($filteredFiles) . " PHP files changed in Git history");

            return $filteredFiles;
        } catch (\Exception $e) {
            $this->error("❌ Error getting files from Git history: " . $e->getMessage());
            return [];
        }
    }

    /**
     * Získá soubory, které selhaly při předchozím zpracování
     */
    private function getFailedFiles(array $watchPaths): array
    {
        if (!$this->gitWatcher->isGitAvailable()) {
            return [];
        }

        try {
            // Získej všechny soubory z historie
            $allHistoryFiles = $this->gitWatcher->getAllChangedFilesInHistory();
            $filteredHistoryFiles = $this->filterChangedFiles($allHistoryFiles, $watchPaths);

            // Získej soubory, které už byly zpracovány
            $documentedFiles = $this->memory->getDocumentedFiles();

            // Najdi soubory, které jsou v historii, ale nejsou zpracované
            $failedFiles = [];
            foreach ($filteredHistoryFiles as $file) {
                if (!in_array($file, $documentedFiles)) {
                    $failedFiles[] = $file;
                }
            }

            return $failedFiles;
        } catch (\Exception $e) {
            return [];
        }
    }

    /**
     * Získá všechny PHP soubory v sledovaných cestách (fallback metoda)
     */
    private function getAllPhpFilesInWatchPaths(array $watchPaths): array
    {
        $allFiles = [];

        foreach ($watchPaths as $watchPath) {
            $fullPath = base_path($watchPath);

            if (!is_dir($fullPath)) {
                continue;
            }

            $iterator = new \RecursiveIteratorIterator(
                new \RecursiveDirectoryIterator($fullPath, \RecursiveDirectoryIterator::SKIP_DOTS)
            );

            foreach ($iterator as $file) {
                if ($file->isFile() && $this->isValidPhpFile($file->getPathname())) {
                    // Převeď na relativní cestu
                    $relativePath = str_replace(base_path() . DIRECTORY_SEPARATOR, '', $file->getPathname());
                    $relativePath = str_replace('\\', '/', $relativePath);
                    $allFiles[] = $relativePath;
                }
            }
        }

        return $allFiles;
    }

    /**
     * Filtruje změněné soubory podle sledovaných cest a PHP rozšíření
     */
    private function filterChangedFiles(array $files, array $watchPaths): array
    {
        $filtered = [];

        foreach ($files as $file) {
            // Zkontroluj jestli je validní PHP soubor
            if (!$this->isValidPhpFile(base_path($file))) {
                continue;
            }

            // Zkontroluj jestli je v sledovaných cestách
            $inWatchPath = false;
            foreach ($watchPaths as $watchPath) {
                if (str_starts_with($file, rtrim($watchPath, '/'))) {
                    $inWatchPath = true;
                    break;
                }
            }

            if ($inWatchPath && file_exists(base_path($file))) {
                $filtered[] = $file;
            }
        }

        return $filtered;
    }

    /**
     * Zkontroluje zda je soubor validní PHP soubor k zpracování
     */
    private function isValidPhpFile(string $filePath): bool
    {
        $extensions = config('digidocs.processing.extensions', ['php']);
        $excludeFiles = config('digidocs.processing.exclude_files', ['*.blade.php']);

        $extension = strtolower(pathinfo($filePath, PATHINFO_EXTENSION));

        if (!in_array($extension, $extensions)) {
            return false;
        }

        $fileName = basename($filePath);
        foreach ($excludeFiles as $pattern) {
            if (fnmatch($pattern, $fileName)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Zobrazí statistiky
     */
    private function showStats(): int
    {
        $stats = $this->memory->getStats();

        $this->info('📊 AutoDocs Statistics');
        $this->line("Total documented files: {$stats['total_files']}");
        $this->line("Files updated in last 7 days: {$stats['recent_updates']}");

        // Statistiky inteligentní analýzy
        if (isset($stats['analysis_enabled']) && $stats['analysis_enabled']) {
            $this->newLine();
            $this->info('🧠 Intelligent Analysis Statistics');
            $this->line("Total analyses performed: {$stats['total_analyses']}");
            $this->line("Documentation regenerations recommended: {$stats['regeneration_recommended']}");
            $this->line("Documentation regenerations skipped: {$stats['regeneration_skipped']}");
            $this->line("Skip rate: {$stats['skip_rate']}%");
            $this->line("Average confidence: {$stats['avg_confidence']}");
            $this->line("Average semantic score: {$stats['avg_semantic_score']}");
            $this->line("Recent analyses (24h): {$stats['recent_analyses']}");
        } else {
            $this->newLine();
            $this->comment('🤖 Intelligent analysis is disabled');
        }

        return 0;
    }

    /**
     * Vyčistí databázi od neexistujících souborů
     */
    private function cleanup(): int
    {
        $this->info('🧹 Cleaning up memory database...');

        $deleted = $this->memory->cleanup();

        $this->line("Removed {$deleted} records for non-existent files");

        return 0;
    }

    /**
     * Zobrazí statistiky nákladů a tokenů
     */
    private function showCostStats(): int
    {
        $stats = $this->memory->getCostStats();

        $this->info('💰 AutoDocs Cost & Token Statistics');
        $this->newLine();

        // Celkové statistiky
        $this->info('📊 Overall Statistics');
        $this->line("Total API calls: {$stats['total_calls']}");
        $this->line("Total input tokens: " . number_format($stats['total_input_tokens']));
        $this->line("Total output tokens: " . number_format($stats['total_output_tokens']));
        $this->line("Total tokens: " . number_format($stats['total_tokens']));
        $this->line("Total cost: $" . number_format($stats['total_cost'], 4));

        // Statistiky podle modelů
        if (!empty($stats['by_model'])) {
            $this->newLine();
            $this->info('🤖 Statistics by Model');
            foreach ($stats['by_model'] as $model => $modelStats) {
                $pricingSource = $this->costTracker->getPricingSource($model);
                $sourceIcon = match($pricingSource) {
                    'config' => '⚙️',
                    default => '📋'
                };

                $this->line("  {$model} {$sourceIcon}:");
                $this->line("    Calls: {$modelStats['calls']}");
                $this->line("    Input tokens: " . number_format($modelStats['input_tokens']));
                $this->line("    Output tokens: " . number_format($modelStats['output_tokens']));
                $this->line("    Cost: $" . number_format($modelStats['cost'], 4));
                $this->line("    Pricing source: {$pricingSource}");
            }
        }

        // Nedávná aktivita
        if (!empty($stats['recent_activity'])) {
            $this->newLine();
            $this->info('📅 Recent Activity (Last 7 days)');
            $this->line("API calls: {$stats['recent_activity']['calls']}");
            $this->line("Tokens used: " . number_format($stats['recent_activity']['tokens']));
            $this->line("Cost: $" . number_format($stats['recent_activity']['cost'], 4));
        }

        // Zobrazit aktuální ceny pro použité modely
        if (!empty($stats['by_model'])) {
            $this->newLine();
            $this->info('💰 Current Model Rates (per 1M tokens)');
            foreach (array_keys($stats['by_model']) as $model) {
                $rates = $this->costTracker->getModelRates($model);
                $source = $this->costTracker->getPricingSource($model);
                $sourceIcon = match($source) {
                    'config' => '⚙️',
                    default => '📋'
                };

                $this->line("  {$model} {$sourceIcon}:");
                $this->line("    Input: $" . number_format($rates['input'], 2) . " / 1M tokens");
                $this->line("    Output: $" . number_format($rates['output'], 2) . " / 1M tokens");
            }
        }

        return 0;
    }
}
</file>

<file path="README.md">
# Digidocs - AI-Powered Laravel Documentation Generator

[![Version](https://img.shields.io/badge/version-1.3.1-blue.svg)](https://github.com/karlost/digidocs)
[![Laravel](https://img.shields.io/badge/Laravel-10%2B-red.svg)](https://laravel.com)
[![PHP](https://img.shields.io/badge/PHP-8.2%2B-purple.svg)](https://php.net)

Digidocs je pokročilý Laravel package pro automatické generování dokumentace PHP kódu pomocí umělé inteligence s využitím NeuronAI frameworku.

> **🆕 Verze 1.3.1** - Kompletně otestovaná verze! Prošla rozsáhlým testováním všech funkcionalit včetně inteligentní analýzy, cost trackingu, error handlingu a recovery. Dokumentovány známé problémy pro transparentnost.

## ✨ Klíčové funkce

- 🤖 **AI-powered dokumentace** - Využívá OpenAI/GPT-4 pro generování kvalitní dokumentace
- 🧠 **Inteligentní analýza změn** - ChangeAnalysisAgent s pokročilými heuristikami pro rozhodování o regeneraci
- 📋 **Tracking dokumentovaných částí** - DocumentationAnalyzer sleduje které části kódu jsou dokumentované
- 🔄 **Git commit monitoring** - Automatické sledování Git commitů a zpracování pouze změněných souborů
- 👁️ **Real-time watch mode** - Kontinuální sledování Git commitů s automatickou regenerací
- 📊 **Sémantická analýza** - Rozlišuje mezi veřejnými API změnami a privátními implementačními detaily
- 💾 **SQLite tracking** - Efektivní sledování změn souborů, commitů, analýz a dokumentovaných částí
- 🛠️ **NeuronAI architektura** - Modulární systém s Agents a Tools
- 🔍 **Laravel kontext** - Rozpoznává Controllers, Models, Commands, Services, atd.
- ⚡ **Artisan commands** - Snadné použití přes CLI
- 🎯 **Efektivní zpracování** - Skip rate až 19% díky inteligentní analýze

## 🚀 Instalace

```bash
composer require karlost/digidocs
```

## ⚙️ Konfigurace

```bash
# 1. Publikuj konfigurační soubor
php artisan vendor:publish --tag=digidocs-config

# 2. Nastav API klíč v .env
AUTODOCS_AI_KEY=your-openai-api-key
```

## 📋 Použití

### 🔄 Automatické generování dokumentace

**Hlavní příkaz** - Zpracovává pouze soubory změněné v Git commitech s inteligentní analýzou:

```bash
# Zpracuje pouze soubory změněné v Git commitech od posledního spuštění
php artisan digidocs:autodocs

# Force regenerace i pro nezměněné soubory
php artisan digidocs:autodocs --force

# Dry run - ukáže co by se zpracovalo
php artisan digidocs:autodocs --dry-run

# Zpracování konkrétních cest
php artisan digidocs:autodocs --path=app/Models --path=app/Services
```

**Inteligentní analýza:**
- 🧠 **ChangeAnalysisAgent** rozhoduje zda regenerovat dokumentaci
- ✅ **Veřejné API změny** → Regeneruje dokumentaci
- ⏭️ **Privátní změny/whitespace** → Přeskakuje regeneraci
- 📊 **Sleduje dokumentované části** kódu pro přesnější rozhodování

### Správa a statistiky

```bash
# Zobraz statistiky dokumentace a inteligentní analýzy
php artisan digidocs:autodocs --stats

# Zobraz statistiky nákladů a tokenů
php artisan digidocs:autodocs --cost

# Vyčisti databázi od neexistujících souborů
php artisan digidocs:autodocs --cleanup
```

### 👁️ Watch Mode - Real-time sledování Git commitů

Pro kontinuální sledování změn v real-time použijte watch mode s inteligentní analýzou:

```bash
# Spusť watch mode - sleduje Git commity v real-time
php artisan digidocs:watch

# Nastav interval kontroly (výchozí 5 sekund)
php artisan digidocs:watch --interval=10

# Sleduj konkrétní cesty
php artisan digidocs:watch --path=app/Models --path=app/Services
```

**Watch mode:**
- 🔄 Sleduje Git commity v real-time (každých 5 sekund)
- 🧠 Používá stejnou inteligentní analýzu jako `autodocs`
- 🛑 Graceful shutdown pomocí Ctrl+C

**Rozdíl mezi režimy:**
- **`autodocs`** - Jednorázové spuštění, zpracuje Git commity od posledního spuštění
- **`watch`** - Kontinuální sledování, automaticky zpracovává nové Git commity

**Výstup obsahuje:**
- 📊 **Celkové statistiky** - počet volání, tokeny, náklady
- 🤖 **Statistiky podle modelů** - detaily pro každý použitý AI model
- 📅 **Nedávná aktivita** - spotřeba za posledních 7 dní
- 💰 **Aktuální ceny** - ceny modelů per 1M tokenů

**Podporované AI providery:**
- ✅ **OpenAI** - GPT-4.1, GPT-4o, GPT-4, GPT-3.5, O3, O4-mini
- ✅ **Anthropic** - Claude 4, Claude 3.7, Claude 3.5, Claude 3
- ✅ **Gemini** - Gemini 1.5 Pro/Flash, Gemini 2.0 Flash
- ✅ **Deepseek** - Deepseek Chat/Coder
- ✅ **Mistral** - Mistral Large/Medium/Small
- ✅ **Ollama** - Lokální modely (zdarma)

**Konfigurace cen:**
Ceny modelů jsou konfigurovatelné v `config/digidocs/pricing.php` a automaticky se aktualizují podle oficiálních cen providerů.

## �🐛 Troubleshooting

### Základní problémy
```bash
# Zkontroluj API klíč a konfiguraci
php artisan config:cache

# Otestuj bez generování dokumentace
php artisan digidocs:autodocs --dry-run

# Zobraz statistiky a stav
php artisan digidocs:autodocs --stats

# Vyčisti databázi od neexistujících souborů
php artisan digidocs:autodocs --cleanup
```

### Git problémy
```bash
# Ujisti se že jsi v Git repository
git status

# Force zpracování aktuálního commitu
php artisan digidocs:autodocs --force
```

### ⚠️ Známé problémy

**Verze 1.3.1 obsahuje následující známé problémy:**

1. **GitAnalyzerTool - trim() errors**
   - Občasné chyby při zpracování Git výstupu
   - Neovlivňuje základní funkcionalitu
   - Workaround: Použij `--force` flag

2. **WatchCommand - path handling**
   - Problémy s duplicitními cestami na Windows
   - Neovlivňuje generování dokumentace
   - Workaround: Restartuj watch command

3. **NeuronAI Tools compatibility**
   - Některé Tools metody nejsou plně kompatibilní s nejnovější verzí NeuronAI
   - Základní funkcionalita funguje správně
   - Plánovaná oprava v příští verzi

**Tyto problémy neovlivňují základní funkcionalitu generování dokumentace a budou opraveny v příští verzi.**

## 💡 Rychlý start

```bash
# 1. Nainstaluj a nakonfiguruj
composer require karlost/digidocs
php artisan vendor:publish --tag=digidocs-config

# 2. Nastav API klíč v .env
AUTODOCS_AI_KEY=your-openai-api-key

# 3. Vygeneruj dokumentaci pro změněné soubory
php artisan digidocs:autodocs

# 4. Nebo spusť watch mode pro automatické sledování
php artisan digidocs:watch
```

### Inteligentní analýza v akci

```bash
# Privátní změny se přeskočí
git commit -m "refactor: improve private method"
# → "⏭️ Skipped (no significant changes)"

# Veřejné API změny se zpracují
git commit -m "feat: add public getData method"
# → "✅ Generated: docs/code/Models/User.md"
```

## 📊 Příklad výstupu

Vygeneruje strukturovanou Markdown dokumentaci s:
- **Přehled souboru** a jeho účel
- **API dokumentace** - veřejné metody a vlastnosti
- **Laravel kontext** - relationships, scopes, atd.
- **Příklady použití** s code examples
</file>

</files>
