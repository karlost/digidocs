<?php

namespace Digihood\Digidocs\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;
use Digihood\Digidocs\Services\MemoryService;
use Digihood\Digidocs\Agent\DocumentationAgent;
use Digihood\Digidocs\Services\GitWatcherService;
use Exception;

class AutoDocsCommand extends Command
{
    protected $signature = 'autodocs {--force : Force regeneration of all documentation}
                                    {--dry-run : Show what would be processed without generating documentation}
                                    {--cleanup : Clean up memory database from non-existent files}
                                    {--stats : Show documentation statistics}
                                    {--path=* : Specific paths to process}
                                    {--all : Process all files instead of only Git changes}';

    protected $description = 'Generate documentation using AI agent for PHP files changed in Git commits';

    public function __construct(
        private MemoryService $memory,
        private DocumentationAgent $agent,
        private GitWatcherService $gitWatcher
    ) {
        parent::__construct();
    }

    public function handle(): int
    {
        $this->info('ü§ñ AutoDocs AI Agent - Starting...');

        // Statistiky
        if ($this->option('stats')) {
            return $this->showStats();
        }

        // Cleanup
        if ($this->option('cleanup')) {
            return $this->cleanup();
        }

        // Zkontroluj Git dostupnost (pokud nen√≠ --all)
        if (!$this->option('all') && !$this->gitWatcher->isGitAvailable()) {
            $this->error("‚ùå Git repository not available. Use --all to process all files or ensure you're in a Git repository.");
            return 1;
        }

        // Z√≠skej seznam soubor≈Ø k anal√Ωze
        $files = $this->getFilesToProcess();

        if (empty($files)) {
            if ($this->option('all')) {
                $this->info('üì≠ No PHP files found to process.');
            } else {
                $this->info('üì≠ No changed PHP files found in recent Git commits.');
            }
            return 0;
        }

        $mode = $this->option('all') ? 'all files' : 'Git changes';
        $this->line("üìã Found " . count($files) . " PHP files to check (mode: {$mode})");

        $processed = 0;
        $skipped = 0;
        $errors = 0;

        foreach ($files as $filePath) {
            $result = $this->processFile($filePath);

            switch ($result) {
                case 'processed':
                    $processed++;
                    break;
                case 'skipped':
                    $skipped++;
                    break;
                case 'error':
                    $errors++;
                    break;
            }
        }

        // Shrnut√≠
        $this->newLine();
        $this->info("‚úÖ Dokonƒçeno!");
        $this->line("üìä Zpracov√°no: {$processed}, P≈ôeskoƒçeno: {$skipped}, Chyb: {$errors}");

        return $errors > 0 ? 1 : 0;
    }

    /**
     * Zpracuje jednotliv√Ω soubor
     */
    private function processFile(string $filePath): string
    {
        $this->line("üìÑ Processing: {$filePath}");

        try {
            // P≈ôeveƒè absolutn√≠ cestu na relativn√≠
            $relativePath = str_replace(base_path() . DIRECTORY_SEPARATOR, '', $filePath);
            $relativePath = str_replace('\\', '/', $relativePath);

            $status = $this->memory->needsDocumentation($relativePath);

            if (isset($status['error'])) {
                $this->line("   ‚ùå Error: {$status['error']}");
                return 'error';
            }

            if (!$this->option('force') && !$status['needs_update']) {
                $this->line("   ‚è≠Ô∏è  Skipped (up to date)");
                return 'skipped';
            }

            if ($this->option('dry-run')) {
                $this->line("   üîç Would process with AI agent");
                return 'processed';
            }

            // Generuj dokumentaci
            $documentation = $this->generateDocumentation($relativePath);

            // Ulo≈æ dokumentaci
            $docPath = $this->saveDocumentation($relativePath, $documentation);

            // Zaznamenej do memory
            $this->memory->recordDocumentation(
                $relativePath,
                $status['current_hash'],
                $docPath
            );

            $this->line("   ‚úÖ Generated: {$docPath}");
            return 'processed';

        } catch (Exception $e) {
            $this->line("   ‚ùå Failed: " . $e->getMessage());
            return 'error';
        }
    }

    /**
     * Vygeneruje dokumentaci pomoc√≠ AI agenta
     */
    private function generateDocumentation(string $filePath): string
    {
        $this->line("   üß† Generating with AI...");

        try {
            return $this->agent->generateDocumentationForFile($filePath);
        } catch (Exception $e) {
            throw new Exception("AI generation failed: " . $e->getMessage());
        }
    }

    /**
     * Ulo≈æ√≠ dokumentaci do souboru
     */
    private function saveDocumentation(string $filePath, string $documentation): string
    {
        $docsPath = config('digidocs.paths.docs');

        // P≈ôeveƒè cestu souboru na cestu dokumentace
        $relativePath = str_replace(['app/', '.php'], ['', '.md'], $filePath);
        $docPath = $docsPath . '/' . $relativePath;

        // Zajisti existenci adres√°≈ôe
        $directory = dirname($docPath);
        if (!File::exists($directory)) {
            File::makeDirectory($directory, 0755, true);
        }

        // Ulo≈ô dokumentaci
        File::put($docPath, $documentation);

        return str_replace(base_path() . '/', '', $docPath);
    }

    /**
     * Z√≠sk√° seznam soubor≈Ø k zpracov√°n√≠
     */
    private function getFilesToProcess(): array
    {
        // Pokud je --all, pou≈æij p≈Øvodn√≠ logiku
        if ($this->option('all')) {
            return $this->getAllFilesToProcess();
        }

        // Jinak pou≈æij Git logiku
        return $this->getGitChangedFiles();
    }

    /**
     * Z√≠sk√° v≈°echny soubory (p≈Øvodn√≠ logika)
     */
    private function getAllFilesToProcess(): array
    {
        $paths = $this->option('path');

        if (empty($paths)) {
            $paths = config('digidocs.paths.watch', ['app/']);
        }

        $files = [];
        $excludeDirs = config('digidocs.processing.exclude_dirs', []);

        foreach ($paths as $path) {
            $fullPath = base_path($path);

            if (!File::exists($fullPath)) {
                $this->line("‚ö†Ô∏è  Path not found: {$path}");
                continue;
            }

            if (File::isFile($fullPath) && $this->isValidPhpFile($fullPath)) {
                $files[] = str_replace(base_path() . '/', '', $fullPath);
            } elseif (File::isDirectory($fullPath)) {
                $foundFiles = $this->scanDirectoryForPhpFiles($fullPath, $excludeDirs);
                $files = array_merge($files, $foundFiles);
            }
        }

        return array_unique($files);
    }

    /**
     * Z√≠sk√° soubory zmƒõnƒõn√© v Git commitech
     */
    private function getGitChangedFiles(): array
    {
        if (!$this->gitWatcher->isGitAvailable()) {
            return [];
        }

        $watchPaths = $this->option('path') ?: config('digidocs.paths.watch', ['app/']);

        // Z√≠skej poslednƒõ zpracovan√Ω commit z memory
        $lastProcessedCommit = $this->memory->getLastProcessedCommit();
        $currentCommit = $this->gitWatcher->getCurrentCommitHashes();

        if (empty($currentCommit)) {
            return [];
        }

        $currentCommitHash = array_values($currentCommit)[0];

        // Pokud je to prvn√≠ spu≈°tƒõn√≠ nebo force, zpracuj soubory z posledn√≠ho commitu
        if (!$lastProcessedCommit || $this->option('force')) {
            $this->line("üîç Processing files from current commit...");
            $changedFiles = $this->gitWatcher->getChangedFilesInCommit($currentCommitHash, $currentCommitHash . '~1');
        } else if ($lastProcessedCommit !== $currentCommitHash) {
            $this->line("üîç Processing files changed since last run...");
            $changedFiles = $this->gitWatcher->getChangedFilesInCommit($currentCommitHash, $lastProcessedCommit);
        } else {
            $this->line("üì≠ No new commits since last run.");
            return [];
        }

        // Filtruj soubory podle konfigurace
        $filteredFiles = $this->filterChangedFiles($changedFiles, $watchPaths);

        // Ulo≈æit aktu√°ln√≠ commit jako zpracovan√Ω
        $this->memory->setLastProcessedCommit($currentCommitHash);

        return $filteredFiles;
    }

    /**
     * Filtruje zmƒõnƒõn√© soubory podle sledovan√Ωch cest a PHP roz≈°√≠≈ôen√≠
     */
    private function filterChangedFiles(array $files, array $watchPaths): array
    {
        $filtered = [];

        foreach ($files as $file) {
            // Zkontroluj jestli je validn√≠ PHP soubor
            if (!$this->isValidPhpFile(base_path($file))) {
                continue;
            }

            // Zkontroluj jestli je v sledovan√Ωch cest√°ch
            $inWatchPath = false;
            foreach ($watchPaths as $watchPath) {
                if (str_starts_with($file, rtrim($watchPath, '/'))) {
                    $inWatchPath = true;
                    break;
                }
            }

            if ($inWatchPath && file_exists(base_path($file))) {
                $filtered[] = $file;
            }
        }

        return $filtered;
    }

    /**
     * Prohled√° adres√°≈ô rekurzivnƒõ pro PHP soubory
     */
    private function scanDirectoryForPhpFiles(string $directory, array $excludeDirs): array
    {
        $files = [];

        $iterator = new \RecursiveIteratorIterator(
            new \RecursiveDirectoryIterator($directory, \RecursiveDirectoryIterator::SKIP_DOTS)
        );

        foreach ($iterator as $file) {
            if (!$file->isFile()) {
                continue;
            }

            $relativePath = str_replace(base_path() . '/', '', $file->getPathname());

            // Zkontroluj vylouƒçen√© adres√°≈ôe
            $shouldExcludeDir = false;
            foreach ($excludeDirs as $excludeDir) {
                if (str_contains($relativePath, $excludeDir)) {
                    $shouldExcludeDir = true;
                    break;
                }
            }

            if ($shouldExcludeDir) {
                continue;
            }

            if ($this->isValidPhpFile($file->getPathname())) {
                $files[] = $relativePath;
            }
        }

        return $files;
    }

    /**
     * Zkontroluje zda je soubor validn√≠ PHP soubor k zpracov√°n√≠
     */
    private function isValidPhpFile(string $filePath): bool
    {
        $extensions = config('digidocs.processing.extensions', ['php']);
        $excludeFiles = config('digidocs.processing.exclude_files', ['*.blade.php']);

        $extension = strtolower(pathinfo($filePath, PATHINFO_EXTENSION));

        if (!in_array($extension, $extensions)) {
            return false;
        }

        $fileName = basename($filePath);
        foreach ($excludeFiles as $pattern) {
            if (fnmatch($pattern, $fileName)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Zobraz√≠ statistiky
     */
    private function showStats(): int
    {
        $stats = $this->memory->getStats();

        $this->info('üìä AutoDocs Statistics');
        $this->line("Total documented files: {$stats['total_files']}");
        $this->line("Files updated in last 7 days: {$stats['recent_updates']}");

        return 0;
    }

    /**
     * Vyƒçist√≠ datab√°zi od neexistuj√≠c√≠ch soubor≈Ø
     */
    private function cleanup(): int
    {
        $this->info('üßπ Cleaning up memory database...');

        $deleted = $this->memory->cleanup();

        $this->line("Removed {$deleted} records for non-existent files");

        return 0;
    }
}
